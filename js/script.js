// Navigation and section handling
let currentSection = 1;
const totalSections = 8;

// Initialize ConfigManager
const configManager = new ConfigManager();

const chapters = [
  { section: 1, title: 'Introductie' },
  { section: 2, title: 'Soorten Zorgtechnologie' },
  { section: 3, title: 'De Kracht van Technologie' },
  { section: 4, title: 'Kritisch Kijken' },
  { section: 5, title: 'Adoptie & Gedrag' },
  { section: 6, title: 'Vinden van Zorgtechnologie' },
  { section: 7, title: 'Jij aan Zet' },
  { section: 8, title: 'Afsluiting' }
];

// New global variables for the redesigned afsluitquiz:
let currentQuizQuestionIndex = 0;
let quizQuestionsData = []; // Will hold questions from afsluitquiz.json
let quizAnswers = []; // Will hold user's answers { id, selected, correct, feedback, questionText, options, title }

function updateProgress() {
    const progressPercentage = ((currentSection - 1) / (totalSections - 1)) * 100;
    const progressFill = document.getElementById('progress-fill');
    if (progressFill) {
        progressFill.style.width = `${progressPercentage}%`;
    }
    const progressText = document.getElementById('progress-percentage');
    if (progressText) {
        progressText.textContent = `${Math.round(progressPercentage)}%`;
    }
    document.querySelectorAll('.chapter-point').forEach((point, index) => {
        point.classList.remove('completed', 'active');
        if (index + 1 < currentSection) {
            point.classList.add('completed');
        } else if (index + 1 === currentSection) {
            point.classList.add('active');
        }
    });
}

function showSection(sectionNumber) {
    window.scrollTo(0, 0);
    document.querySelectorAll('section').forEach(section => {
        section.style.display = 'none';
        section.classList.remove('active');
    });
    const targetSection = document.querySelector(`section[data-section="${sectionNumber}"]`);
    if (targetSection) {
        targetSection.style.display = 'block';
        targetSection.classList.add('active');
        currentSection = sectionNumber;
        updateProgress();
        document.querySelectorAll('.sidebar-chapter').forEach(ch => ch.classList.remove('active'));
        const activeSidebar = document.querySelector(`.sidebar-chapter[data-section="${sectionNumber}"]`);
        if (activeSidebar) activeSidebar.classList.add('active');

        // Navigatieknoppen tonen/verbergen
        const navButtons = targetSection.querySelector('.nav-buttons');
        if (navButtons) {
            const prevBtn = navButtons.querySelector('.btn-prev');
            const nextBtn = navButtons.querySelector('.btn-next');
            if (prevBtn) prevBtn.style.display = sectionNumber === 1 ? 'none' : '';
            if (nextBtn) nextBtn.style.display = sectionNumber === totalSections ? 'none' : '';
        }

        // Load dynamic text content for the new section
        if (typeof loadContentForSection === 'function') {
            loadContentForSection(currentSection); // This loads hoofdstukN.json or hoofdstuk_afsluiting.json
        }

        // If the section being shown is the last section (afsluiting), also load the Afsluitquiz
        if (parseInt(sectionNumber) === totalSections) {
            if (typeof loadMCQuiz === 'function') {
                console.log("Afsluiting section activated, attempting to load Afsluitquiz.");
                loadMCQuiz(); // This loads afsluitquiz.json
            } else {
                console.error("loadMCQuiz function is not defined.");
            }
        }

        setTimeout(() => {
            window.scrollTo({ top: 0, behavior: 'instant' });
            // initializeDragAndDrop() was here, but drag-drop init is now handled by dynamicContent.js
            // if (typeof initializeDragAndDrop === 'function') initializeDragAndDrop(); 
        }, 50);
    }
}

function nextSection() {
    if (currentSection < totalSections) {
        showSection(currentSection + 1);
    }
}

function prevSection() {
    if (currentSection > 1) {
        showSection(currentSection - 1);
    }
}

async function loadHoofdstuk(nr) {
    // THIS FUNCTION IS NOW OBSOLETE AND WILL BE REMOVED
    // All its logic is being moved or adapted into js/dynamicContent.js
    // and the global interaction handlers in this file (js/script.js)
}

function renderMC(mc, targetId) {
    // REMOVE renderMC, renderReflection, renderDragDrop, renderSelfAssessment
    // The HTML structure is now generated by js/dynamicContent.js.
    // The logic functions (saveReflection, checkDragDrop etc.) remain.
}

function renderReflection(ref, targetId, sectionNumber) {
    // REMOVE renderMC, renderReflection, renderDragDrop, renderSelfAssessment
    // The HTML structure is now generated by js/dynamicContent.js.
    // The logic functions (saveReflection, checkDragDrop etc.) remain.
}

function renderDragDrop(dd, targetId, sectionNumber) {
    // REMOVE renderMC, renderReflection, renderDragDrop, renderSelfAssessment
    // The HTML structure is now generated by js/dynamicContent.js.
    // The logic functions (saveReflection, checkDragDrop etc.) remain.
}

function renderSelfAssessment(sa, targetId, sectionNumber) {
    // REMOVE renderMC, renderReflection, renderDragDrop, renderSelfAssessment
    // The HTML structure is now generated by js/dynamicContent.js.
    // The logic functions (saveReflection, checkDragDrop etc.) remain.
}

async function saveSelfAssessment(sectionNumber, selfAssessmentId) {
    const ids = ['veranderen', 'vinden', 'vertrouwen', 'vaardiggebruiken', 'vertellen'];
    let allAnswered = true;
    const assessmentData = {};

    ids.forEach(idName => {
        const selectElement = document.getElementById(`${idName}-${sectionNumber}-${selfAssessmentId}`);
        if (selectElement && selectElement.value) {
            assessmentData[idName] = selectElement.value;
        } else {
            allAnswered = false;
        }
    });

    const feedbackEl = document.getElementById(`feedback-${sectionNumber}-${selfAssessmentId}`);
    const button = document.querySelector(`.selfassessment-interaction button[onclick*="saveSelfAssessment(${sectionNumber}, '${selfAssessmentId}')"]`);

    if (!allAnswered) {
        if (feedbackEl) {
            feedbackEl.textContent = 'Beoordeel alstublieft alle competenties.';
            feedbackEl.className = 'feedback-message incorrect';
        }
        return;
    }
    localStorage.setItem(`selfassessment_${sectionNumber}_${selfAssessmentId}_done`, JSON.stringify(assessmentData));
    
    if (feedbackEl) {
        feedbackEl.textContent = 'Zelfbeoordeling opgeslagen!';
        feedbackEl.className = 'feedback-message correct';
    }
    if (button) {
        button.textContent = 'Opgeslagen';
        button.disabled = true;
        button.classList.add('btn-opgeslagen');
    }
    // Disable all select elements as well
    ids.forEach(idName => {
        const selectElement = document.getElementById(`${idName}-${sectionNumber}-${selfAssessmentId}`);
        if (selectElement) {
            selectElement.disabled = true;
        }
    });

    await updateAllChapterProgress();
}

// Reinstated saveReflection
async function saveReflection(sectionNumber, reflectionId) {
    const reflectionInput = document.getElementById(`${reflectionId}-input`); 
    if (!reflectionInput) {
        console.error(`Reflection input field with ID ${reflectionId}-input not found.`);
        // alert('Fout: reflectieveld niet gevonden.'); // Verwijderd
        const feedbackEl = document.getElementById(`feedback-${sectionNumber}-${reflectionId}`);
        if (feedbackEl) {
            feedbackEl.textContent = 'Fout: reflectieveld niet gevonden.';
            feedbackEl.className = 'feedback-message incorrect';
        }
        return false;
    }
    const answer = reflectionInput.value.trim();
    
    const interactionData = await getInteractionData(sectionNumber, reflectionId);
    const minLength = interactionData && interactionData.minLength ? interactionData.minLength : 10;
    const feedbackEl = document.getElementById(`feedback-${sectionNumber}-${reflectionId}`);

    if (answer.length < minLength) {
        // alert(`Je antwoord moet minimaal ${minLength} tekens bevatten.`); // Verwijderd
        if (feedbackEl) {
            feedbackEl.textContent = `Je antwoord moet minimaal ${minLength} tekens bevatten.`;
            feedbackEl.className = 'feedback-message incorrect';
        }
        return false;
    }
    const storageKey = `reflection_${sectionNumber}_${reflectionId}_answered`; 
    localStorage.setItem(storageKey, answer);
    // alert('Reflectie opgeslagen!'); // Verwijderd
    
    const button = reflectionInput.nextElementSibling;
    if (button && button.tagName === 'BUTTON' && button.classList.contains('btn-save-reflection')) {
        button.textContent = 'Opgeslagen';
        button.disabled = true;
        button.classList.add('btn-opgeslagen');
        reflectionInput.readOnly = true; // Maak textarea ook readonly
    }
    if (feedbackEl) {
        feedbackEl.textContent = 'Reflectie opgeslagen!';
        feedbackEl.className = 'feedback-message correct';
    }
    await updateAllChapterProgress();
    return true;
}

function saveMCScore(questionNumber, correct, total) {
    localStorage.setItem(`mc${questionNumber}_correct`, correct);
    localStorage.setItem(`mc${questionNumber}_total`, total);
    // De updateAllChapterProgress voor de afsluitquiz (H8) checkt mc_quiz_answers.
}

async function updateAllChapterProgress() {
    console.log('updateAllChapterProgress gestart');
    // Dynamisch genereren van chaptersToUpdate op basis van totalSections
    // Alle hoofdstukken behalve het laatste (afsluitend hoofdstuk)
    const chaptersToUpdate = Array.from({length: totalSections - 1}, (_, i) => i + 1);
    let chapterProgress = JSON.parse(localStorage.getItem('chapterProgress')) || Array(totalSections).fill(0);

    for (let i = 0; i < chaptersToUpdate.length; i++) {
        let h = chaptersToUpdate[i];
        let ingevuld = 0;
        let totaal = 0;
        try {
            const res = await fetch(`content/hoofdstuk${h}.json`);
            if (!res.ok) {
                console.warn(`Hoofdstuk ${h} JSON niet gevonden (${res.status})`);
                chapterProgress[h - 1] = 0;
                continue;
            }
            const data = await res.json();
            if (!data.interacties || data.interacties.length === 0) {
                chapterProgress[h - 1] = 1; 
                console.log(`Hoofdstuk ${h} heeft geen interacties, gemarkeerd als voltooid.`);
                continue;
            }
            totaal = data.interacties.length;
            for (const interactie of data.interacties) {
                if (interactie.type === 'reflection') {
                    if (localStorage.getItem(`reflection_${h}_${interactie.id}_answered`)) ingevuld++;
                } else if (interactie.type === 'mc') {
                    if (localStorage.getItem(`mc_${h}_${interactie.id}_answered`)) ingevuld++;
                } else if (interactie.type === 'dragdrop') {
                    if (localStorage.getItem(`dragdrop_${h}_${interactie.id}_correct`)) ingevuld++;
                } else if (interactie.type === 'selfassessment') {
                    if (localStorage.getItem(`selfassessment_${h}_${interactie.id}_done`)) ingevuld++;
                } else if (interactie.type === 'critical_analysis') {
                    if (localStorage.getItem(`critical_analysis_${h}_${interactie.id}_answered`)) ingevuld++;
                } else if (interactie.type === 'flashcard') {
                    if (localStorage.getItem(`flashcard_${h}_${interactie.id}_done`)) ingevuld++;
                }
            }
            if (totaal > 0) {
                if (ingevuld === totaal) chapterProgress[h - 1] = 1;
                else if (ingevuld > 0) chapterProgress[h - 1] = 0.5;
                else chapterProgress[h - 1] = 0;
            }
            console.log(`Hoofdstuk ${h}: Totaal Interacties: ${totaal}, Ingevuld: ${ingevuld}, Status: ${chapterProgress[h-1]}`);
        } catch (e) {
            console.error(`Fout bij verwerken voortgang H${h}:`, e);
            chapterProgress[h - 1] = 0;
        }
    }

    // Afsluitend hoofdstuk (laatste sectie): afsluitquiz
    let quizDone = false;
    try {
        const resQuiz = await fetch('content/afsluitquiz.json');
        if (resQuiz.ok) {
            const afsluitQuizData = await resQuiz.json();
            const quizAnswers = JSON.parse(localStorage.getItem('mc_quiz_answers') || '[]');
            if (Array.isArray(quizAnswers) && quizAnswers.length === afsluitQuizData.length && quizAnswers.every(a => a && typeof a.selected !== 'undefined')) {
                quizDone = true;
            }
        }
    } catch (e) { console.error('Fout bij verwerken afsluitquiz progress:', e); }
    chapterProgress[totalSections - 1] = quizDone ? 1 : 0; // Index voor laatste hoofdstuk
    console.log(`Hoofdstuk ${totalSections} (Afsluitquiz) Status: ${chapterProgress[totalSections - 1]}`);

    localStorage.setItem('chapterProgress', JSON.stringify(chapterProgress));
    console.log('Chapter progress opgeslagen:', chapterProgress);

    // Dynamisch genereren van chapterMeta op basis van totalSections
    const chapterMeta = Array.from({length: totalSections}, (_, i) => ({ section: i + 1 }));
    chapterMeta.forEach((ch, idx) => {
        const circle = document.getElementById(`circle-${ch.section}`);
        if (!circle) return;
        circle.classList.remove('completed', 'half');
        if (chapterProgress[idx] === 1) {
            circle.classList.add('completed');
        } else if (chapterProgress[idx] === 0.5) {
            circle.classList.add('half');
        }
    });

    let completed = chapterProgress.filter(p => p === 1).length;
    let half = chapterProgress.filter(p => p === 0.5).length;
    let percent = Math.round((completed + 0.5 * half) / totalSections * 100);
    const visual = document.getElementById('sidebarProgressVisual');
    if (visual) {
        visual.style.background = `conic-gradient(var(--primary-purple) 0% ${percent}%, var(--medium-gray) ${percent}% 100%)`;
    }
    const text = document.getElementById('sidebarProgressText');
    if (text) text.textContent = percent + '%';
    console.log('Sidebar progress UI geüpdatet.');
}

function setupSidebarNavigation() {
    console.log('Setting up sidebar navigation...');
    const sidebarChapters = document.querySelectorAll('.sidebar-chapter');
    sidebarChapters.forEach(chapter => {
        chapter.addEventListener('click', function () {
            const sectionNumber = parseInt(this.getAttribute('data-section'));
            if (sectionNumber !== currentSection) {
                showSection(sectionNumber);
            }
            // Sidebar sluiten op mobiel na klik op hoofdstuk
            const sidebar = document.getElementById('sidebarNav');
            const floatingHamburger = document.getElementById('floatingHamburger');
            if (window.innerWidth <= 900 && sidebar.classList.contains('open')) {
                sidebar.classList.remove('open');
                document.body.classList.remove('sidebar-open');
                if (floatingHamburger) floatingHamburger.classList.remove('active');
            }
        });
    });
}

function setupSidebarHamburger() {
    console.log('Setting up sidebar hamburger...');
    const sidebarHamburger = document.getElementById('sidebarHamburger');
    const floatingHamburger = document.getElementById('floatingHamburger');
    const sidebar = document.getElementById('sidebarNav');
    const sidebarOverlay = document.querySelector('.sidebar-overlay');

    function toggleSidebar(event) {
        if (event) event.stopPropagation();
        sidebar.classList.toggle('open');
        document.body.classList.toggle('sidebar-open');
    }

    if (sidebarHamburger) sidebarHamburger.addEventListener('click', toggleSidebar);
    if (floatingHamburger) floatingHamburger.addEventListener('click', toggleSidebar);
    if (sidebarOverlay) sidebarOverlay.addEventListener('click', toggleSidebar);

    document.addEventListener('click', function (event) {
        if (sidebar && sidebar.classList.contains('open')) {
            const isClickInsideSidebar = sidebar.contains(event.target);
            const isClickOnFloatingHamburger = floatingHamburger && floatingHamburger.contains(event.target);
            if (!isClickInsideSidebar && !isClickOnFloatingHamburger) {
                toggleSidebar();
            }
        }
    });
}

async function loadMCQuiz() { // Voor afsluitquiz
    console.log('loadMCQuiz aangeroepen (NIEUWE VERSIE)');
    const quizContainer = document.getElementById('quiz-container');
    if (!quizContainer) {
        console.warn('Quiz container #quiz-container niet gevonden in loadMCQuiz.');
        const section8Content = document.querySelector('#section8 .section-content');
        if (section8Content) {
            const newQuizContainer = document.createElement('div');
            newQuizContainer.id = 'quiz-container';
            // Insert before the <h3>Certificaat Genereren</h3> if possible
            const h3Cert = section8Content.querySelector('h3');
            if (h3Cert) {
                section8Content.insertBefore(newQuizContainer, h3Cert);
            } else {
                section8Content.appendChild(newQuizContainer);
            }
            console.warn('#quiz-container was missing, created it dynamically.');
        } else {
            document.body.innerHTML = '<p style="color:red;text-align:center;font-size:18px;">Kritieke Fout: Quiz container kon niet gevonden of aangemaakt worden. Neem contact op.</p>';
            return;
        }
    }
    document.getElementById('quiz-container').innerHTML = '<p>Quiz aan het laden...</p>';
    try {
        const res = await fetch('content/afsluitquiz.json');
        if (!res.ok) {
            throw new Error(`Afsluitquiz JSON niet gevonden (${res.status})`);
        }
        const loadedData = await res.json();
        if (!Array.isArray(loadedData) || loadedData.length === 0) {
             console.warn('Afsluitquiz JSON is leeg of ongeldig formaat.');
             document.getElementById('quiz-container').innerHTML = '<p style="color:red;">Fout: Quizdata is leeg of ongeldig.</p>';
             return;
        }
        quizQuestionsData = loadedData;
        let storedAnswers = JSON.parse(localStorage.getItem('mc_quiz_answers')) || [];
        quizAnswers = storedAnswers.filter(ans => quizQuestionsData.some(q => q.id === ans.id));
        localStorage.setItem('mc_quiz_answers', JSON.stringify(quizAnswers));

        currentQuizQuestionIndex = 0; 
        renderCurrentQuizQuestion();
    } catch (e) {
        console.error('Fout bij laden afsluitquiz:', e);
        if(document.getElementById('quiz-container')) document.getElementById('quiz-container').innerHTML = `<p style="color:red;">Kon afsluitquiz niet laden: ${e.message}</p>`;
    }
}

function renderCurrentQuizQuestion() {
    const quizContainer = document.getElementById('quiz-container');
    if (!quizContainer) { 
        console.error("renderCurrentQuizQuestion: quizContainer niet gevonden!");
        return;
    }
    if (quizQuestionsData.length === 0) {
        quizContainer.innerHTML = '<p>Geen vragen beschikbaar voor de quiz.</p>';
        return;
    }
    
    const allQuestionsAnswered = quizQuestionsData.every(q => quizAnswers.some(a => a.id === q.id && typeof a.selected !== 'undefined'));

    if (currentQuizQuestionIndex >= quizQuestionsData.length) {
        displayQuizResults();
        return;
    }

    const q = quizQuestionsData[currentQuizQuestionIndex];
    if (!q) {
        console.error(`Kon vraag data niet vinden voor index ${currentQuizQuestionIndex}`);
        quizContainer.innerHTML = `<p style=\"color:red;\">Fout: Kon vraag ${currentQuizQuestionIndex + 1} niet laden.</p>
                                   <button class=\"btn\" onclick=\"displayQuizResults()\">Toon Resultaten</button>`;
        return;
    }
    
    const existingAnswer = quizAnswers.find(a => a.id === q.id);
    const isAnswered = !!existingAnswer;

    // Shuffle opties per vraag, maar alleen als nog niet beantwoord
    let shuffledOptions, correctIndex;
    if (!isAnswered) {
        // Fisher-Yates shuffle
        shuffledOptions = q.options.map((opt, idx) => ({ opt, idx: idx + 1 }));
        for (let i = shuffledOptions.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [shuffledOptions[i], shuffledOptions[j]] = [shuffledOptions[j], shuffledOptions[i]];
        }
        // Sla de volgorde tijdelijk op in de vraag zelf zodat bij feedback de juiste index bekend is
        q._shuffledOptions = shuffledOptions;
        // Bepaal de nieuwe index van het juiste antwoord
        correctIndex = shuffledOptions.findIndex(o => o.idx === q.correctAnswer) + 1;
        q._shuffledCorrectIndex = correctIndex;
    } else {
        // Bij review: gebruik opgeslagen volgorde
        shuffledOptions = q._shuffledOptions || q.options.map((opt, idx) => ({ opt, idx: idx + 1 }));
        correctIndex = q._shuffledCorrectIndex || q.correctAnswer;
    }

    // Add question counter
    const questionCounter = `<div class="question-counter" style="text-align: right; margin-bottom: 10px; color: #666;">Vraag ${currentQuizQuestionIndex + 1} van ${quizQuestionsData.length}</div>`;

    let showOptions = isAnswered; // Als al beantwoord, altijd tonen
    // Voeg een klasse toe voor initiële hoogte als opties nog niet getoond zijn
    const showOptionsBlockClass = !isAnswered ? 'initial-height' : '';

    let output = `
        <div class="mc-question afsluitquiz-vraag ${isAnswered ? 'answered' : ''}" id="quizq-${q.id}" data-question-index="${currentQuizQuestionIndex}">
            ${questionCounter}
            <h4>${q.title || `Vraag ${currentQuizQuestionIndex + 1}`}</h4>
            <p>${q.text}</p>
            <div id="show-options-block" class="${showOptionsBlockClass}">
                ${!isAnswered ? `<button class="btn btn-show-options" id="show-options-btn">Toon antwoordopties</button>
                <div class="show-options-explainer" style="font-size: 0.95em; color: #666; margin-top: 6px; margin-bottom: 12px;">Probeer eerst het antwoord uit je hoofd te bedenken. Lukt dat niet? Klik dan op de knop om de antwoordopties te zien. Dit helpt je beter te leren!</div>` : ''}
                <ul class="mc-options" id="mc-options-list" style="${!showOptions ? 'display:none;' : ''}">
                    ${shuffledOptions.map((o, i) => {
                        let optionClasses = "mc-option";
                        if (isAnswered) {
                            optionClasses += " disabled"; 
                            if (existingAnswer.selected === (i + 1)) {
                                optionClasses += " selected";
                                optionClasses += existingAnswer.correct ? " correct" : " incorrect";
                            }
                        }
                        return `<li class="${optionClasses}" data-question-id="${q.id}" data-option-id="${i + 1}">${o.opt}</li>`;
                    }).join('')}
                </ul>
            </div>
            <div class="feedback" id="feedback-quizq-${q.id}">${isAnswered && existingAnswer.feedback ? existingAnswer.feedback : ''}</div>
        </div>
        <div class="quiz-navigation-buttons">
            <button class="btn btn-prev-quiz" ${currentQuizQuestionIndex === 0 ? 'disabled' : ''} onclick="prevQuizQuestion()">Vorige Vraag</button>
            <button class="btn btn-next-quiz" 
                ${(!isAnswered && currentQuizQuestionIndex < quizQuestionsData.length) ? 'disabled' : ''} 
                onclick="nextQuizQuestion()">
                ${(currentQuizQuestionIndex === quizQuestionsData.length - 1) ? 'Quiz voltooien' : 'Volgende Vraag'}
            </button>
        </div>
    `;
    quizContainer.innerHTML = output;

    // Logica voor tonen van opties na klik
    if (!isAnswered) {
        const showOptionsBtn = quizContainer.querySelector('#show-options-btn');
        const explainerText = quizContainer.querySelector('.show-options-explainer'); // Selecteer de explainer tekst
        if (showOptionsBtn) {
            showOptionsBtn.addEventListener('click', function() {
                const optionsList = quizContainer.querySelector('#mc-options-list');
                if (optionsList) optionsList.style.display = '';
                showOptionsBtn.style.display = 'none';
                if (explainerText) explainerText.style.display = 'none'; // Verberg de explainer tekst
                // Verwijder de initiële hoogte klasse
                const showOptionsBlock = quizContainer.querySelector('#show-options-block');
                if (showOptionsBlock) showOptionsBlock.classList.remove('initial-height');
            });
        }
    }

    if (!isAnswered) { 
        const options = quizContainer.querySelectorAll('.mc-option:not(.disabled)');
        options.forEach(option => {
            option.addEventListener('click', function() {
                // Bepaal de juiste index op basis van de huidige shuffle
                const questionId = this.getAttribute('data-question-id');
                const optionId = parseInt(this.getAttribute('data-option-id'));
                const questionDiv = this.closest('.mc-question');
                const questionData = quizQuestionsData.find(q => q.id === questionId);
                const correctIndex = questionData._shuffledCorrectIndex || questionData.correctAnswer;
                if (questionDiv.classList.contains('answered') || !questionData) return;
                questionDiv.querySelectorAll('.mc-option').forEach(opt => opt.classList.add('disabled'));
                const isCorrect = optionId === correctIndex;
                this.classList.add('selected');
                this.classList.add(isCorrect ? 'correct' : 'incorrect');
                const feedbackEl = questionDiv.querySelector('.feedback');
                feedbackEl.textContent = questionData.feedback;
                feedbackEl.className = 'feedback ' + (isCorrect ? 'correct' : 'incorrect');
                questionDiv.classList.add('answered');
                let answerIndex = quizAnswers.findIndex(a => a.id === questionId);
                const answerObj = { 
                    id: questionId, 
                    selected: optionId, 
                    correct: isCorrect, 
                    feedback: questionData.feedback, 
                    questionText: questionData.text, 
                    options: shuffledOptions.map(o => o.opt),
                    title: questionData.title 
                };
                if (answerIndex > -1) {
                    quizAnswers[answerIndex] = answerObj;
                } else {
                    quizAnswers.push(answerObj);
                }
                localStorage.setItem('mc_quiz_answers', JSON.stringify(quizAnswers));
                const nextButton = document.querySelector('.btn-next-quiz');
                if (nextButton) nextButton.disabled = false;
                updateAllChapterProgress(); 
            });
        });
    } else {
        const feedbackEl = quizContainer.querySelector(`#feedback-quizq-${q.id}`);
        if (feedbackEl && existingAnswer) {
           feedbackEl.className = 'feedback ' + (existingAnswer.correct ? 'correct' : 'incorrect');
        }
        const nextButton = quizContainer.querySelector('.btn-next-quiz');
        if (nextButton) nextButton.disabled = false;
    }
}

function handleQuizOptionClick() {
    const questionId = this.getAttribute('data-question-id');
    const optionId = parseInt(this.getAttribute('data-option-id'));
    const questionDiv = this.closest('.mc-question');
    const questionData = quizQuestionsData.find(q => q.id === questionId);

    if (questionDiv.classList.contains('answered') || !questionData) return;

    questionDiv.querySelectorAll('.mc-option').forEach(opt => opt.classList.add('disabled')); 

    const isCorrect = optionId === questionData.correctAnswer;
    this.classList.add('selected');
    this.classList.add(isCorrect ? 'correct' : 'incorrect');

    const feedbackEl = questionDiv.querySelector('.feedback');
    feedbackEl.textContent = questionData.feedback;
    feedbackEl.className = 'feedback ' + (isCorrect ? 'correct' : 'incorrect');
    
    questionDiv.classList.add('answered');
    
    let answerIndex = quizAnswers.findIndex(a => a.id === questionId);
    const answerObj = { 
        id: questionId, 
        selected: optionId, 
        correct: isCorrect, 
        feedback: questionData.feedback, 
        questionText: questionData.text, 
        options: questionData.options,
        title: questionData.title 
    };
    if (answerIndex > -1) {
        quizAnswers[answerIndex] = answerObj;
    } else {
        quizAnswers.push(answerObj);
    }
    localStorage.setItem('mc_quiz_answers', JSON.stringify(quizAnswers));

    const nextButton = document.querySelector('.btn-next-quiz');
    if (nextButton) nextButton.disabled = false;
    
    updateAllChapterProgress(); 
}

function nextQuizQuestion() {
    const allQuestionsAnswered = quizQuestionsData.every(q => quizAnswers.some(a => a.id === q.id && typeof a.selected !== 'undefined'));
    if (currentQuizQuestionIndex < quizQuestionsData.length - 1) {
        currentQuizQuestionIndex++;
        renderCurrentQuizQuestion();
    } else if (allQuestionsAnswered || currentQuizQuestionIndex === quizQuestionsData.length - 1) {
        displayQuizResults();
    } else {
         console.warn("NextQuizQuestion called on last question, but not all answered. Showing results.");
         displayQuizResults();
    }
}

function prevQuizQuestion() {
    if (currentQuizQuestionIndex > 0) {
        currentQuizQuestionIndex--;
        renderCurrentQuizQuestion();
    }
}

function displayQuizResults() {
    const quizContainer = document.getElementById('quiz-container');
    if (!quizContainer) { console.error("displayQuizResults: quizContainer niet gevonden!"); return; }

    let score = 0;
    quizAnswers.forEach(ans => {
        if (quizQuestionsData.some(q => q.id === ans.id) && ans.correct) {
            score++;
        }
    });
    const totalQuizQuestions = quizQuestionsData.length;
    const percentage = totalQuizQuestions > 0 ? (score / totalQuizQuestions) * 100 : 0;
    
    // Bepaal feedback op basis van percentage
    let feedbackMessage = '';
    let feedbackColor = '';
    let feedbackClass = '';
    
    if (percentage >= 80) {
        feedbackMessage = 'Fantastisch gedaan! Je hebt de stof uitstekend verwerkt.';
        feedbackColor = '#28a745';
        feedbackClass = 'results-excellent';
    } else if (percentage >= 65) {
        feedbackMessage = 'Goed gedaan! Je hebt een goed begrip van de stof.';
        feedbackColor = '#28a745';
        feedbackClass = 'results-passed';
    } else if (percentage >= 55) {
        feedbackMessage = 'Goed bezig! Je hebt de basis onder de knie, maar er is nog ruimte voor verbetering. Herhaal de quiz om je score nog verder te verhogen.';
        feedbackColor = '#28a745';
        feedbackClass = 'results-passed';
    } else if (percentage >= 40) {
        feedbackMessage = 'Bijna! Het is verstandig om de quiz te herhalen en de stof nog eens door te nemen.';
        feedbackColor = '#ffc107';
        feedbackClass = 'results-warning';
    } else {
        feedbackMessage = 'Het is aan te raden om de e-learning nog eens door te nemen en daarna de quiz te herhalen.';
        feedbackColor = '#dc3545';
        feedbackClass = 'results-failed';
    }

    let resultsHTML = `
        <div id="quiz-results-container" class="${feedbackClass}">
            <div class="results-header">
                <h2>Afsluitende Quiz - Resultaten</h2>
            </div>
            <div class="results-summary" style="text-align: center; padding: 20px;">
                <div class="score-text" style="max-width: 500px; margin: 0 auto; border: 3px solid ${feedbackColor}; border-radius: 18px; background: #f8f6ff; box-shadow: 0 2px 12px 0 rgba(124,58,237,0.08); padding: 32px 24px 24px 24px; margin-bottom: 30px;">
                    <p style="font-size: 1.2em; margin-bottom: 10px;">Je hebt <strong>${score} van de ${totalQuizQuestions}</strong> vragen correct beantwoord.</p>
                    <p style="font-size: 1.5em; font-weight: bold; color: ${feedbackColor}; margin-bottom: 20px;">${percentage.toFixed(0)}%</p>
                    <p class="feedback-message" style="color: ${feedbackColor}; font-size: 1.1em;">${feedbackMessage}</p>
                </div>
            </div>
            <div class="quiz-actions">
                <button class="btn btn-restart-quiz" onclick="restartQuiz()">
                    <img src="images/icons/restart-icon.svg" alt="" class="btn-icon"> Quiz Herstarten
                </button>
                ${totalQuizQuestions > 0 ? `<button class="btn btn-review-answers" onclick="reviewQuizQuestion(0)"><img src="images/icons/review-icon.svg" alt="" class="btn-icon">Antwoorden terugkijken</button>` : ''}
            </div>
        </div>
        <div id="quiz-review-details-container" style="margin-top: 30px; padding-top: 20px; border-top: 1px solid var(--medium-gray);"> 
            <!-- Review content will be loaded here by reviewQuizQuestion if user clicks "Antwoorden terugkijken" -->
        </div>
    `;
    quizContainer.innerHTML = resultsHTML;
    updateAllChapterProgress(); 
}

function restartQuiz() {
    quizAnswers = [];
    localStorage.setItem('mc_quiz_answers', JSON.stringify(quizAnswers)); 
    currentQuizQuestionIndex = 0;
    if (quizQuestionsData.length === 0) { 
        loadMCQuiz(); 
    } else {
        renderCurrentQuizQuestion();
    }
}

function reviewQuizQuestion(questionIndex) {
    currentQuizQuestionIndex = questionIndex; 
    const quizContainer = document.getElementById('quiz-container'); 
    // The results HTML is already in quizContainer. We will replace #quiz-review-details-container
    const reviewDetailContainer = document.getElementById('quiz-review-details-container');

    if (!reviewDetailContainer) { 
        console.error("reviewQuizQuestion: quiz-review-details-container niet gevonden!"); 
        // As a fallback, could replace the whole quizContainer, but that loses the summary.
        // For now, if container is missing, we show an error or do nothing further for review.
        if(quizContainer) quizContainer.innerHTML += "<p style='color:red'>Kan review details niet laden.</p>";
        return; 
    }

    if (!quizQuestionsData || questionIndex < 0 || questionIndex >= quizQuestionsData.length) {
        reviewDetailContainer.innerHTML = `<p>Kan deze vraag niet voor terugkijken laden.</p>`;
        return;
    }

    const q = quizQuestionsData[questionIndex];
    const userAnswer = quizAnswers.find(a => a.id === q.id);
    const isCorrect = userAnswer ? userAnswer.correct : false;

    let output = `
        <div class="mc-question afsluitquiz-vraag answered review-mode" id="review-quizq-${q.id}">
            <h4>Terugkijken: ${q.title || `Vraag ${questionIndex + 1}`} (van ${quizQuestionsData.length})</h4>
            <p><strong>Vraag:</strong> ${q.text}</p>
            <ul class="mc-options review-options">
                ${q.options.map((opt, i) => {
                    let classes = 'mc-option disabled'; 
                    const optionNum = i + 1;
                    let icon = '';

                    if (userAnswer && userAnswer.selected === optionNum) {
                        classes += ' selected';
                        classes += userAnswer.correct ? ' correct' : ' incorrect';
                        icon = userAnswer.correct ? '<img src="images/icons/check-circle.svg" class="option-icon correct-icon" alt="Correct">' : '<img src="images/icons/x-circle.svg" class="option-icon incorrect-icon" alt="Incorrect">' ;
                    } else if (q.correctAnswer === optionNum) {
                        classes += ' correct-unselected'; 
                        icon = '<img src="images/icons/check-circle-outline.svg" class="option-icon correct-icon-outline" alt="Correct Answer">';
                    }
                    return `<li class="${classes}">${icon} ${opt}</li>`;
                }).join('')}
            </ul>
            <div class="feedback ${isCorrect ? 'correct' : 'incorrect'}">
                <strong>Feedback:</strong> ${q.feedback || (userAnswer && userAnswer.feedback) || "Geen feedback beschikbaar."}
            </div>
        </div>
        <div class="quiz-navigation-buttons review-nav-buttons">
            <button class="btn" onclick="reviewQuizQuestion(${questionIndex - 1})" ${questionIndex === 0 ? 'disabled' : ''}>Vorige Vraag (terugkijken)</button>
            <button class="btn" onclick="reviewQuizQuestion(${questionIndex + 1})" ${questionIndex === quizQuestionsData.length - 1 ? 'disabled' : ''}>Volgende Vraag (terugkijken)</button>
            <!-- Removed "Terug naar Resultaten" as results summary stays visible -->
        </div>
    `;
    reviewDetailContainer.innerHTML = output; 
}

// ALLERLAATST IN HET BESTAND:
document.addEventListener('DOMContentLoaded', async function() {
    // Load configuration first
    await configManager.loadConfig();
    
    setupSidebarNavigation();
    setupSidebarHamburger();
    
    // Initial section display and content load
    showSection(currentSection); // This will also call loadContentForSection internally for the currentSection

    // updateAllChapterProgress(); // This is called after interactions too, might be redundant here if showSection/loadContent handles it
    
    // Load quiz questions for section 8 (Afsluitquiz)
    // This is specific to section 8 and not part of the general chapter loading.
    // It might be better to call this when section 8 becomes active.
    // if (document.getElementById('quiz-container')) { // Check if the container exists
    //     await loadMCQuiz(); 
    // }

    // If section8 is active on initial load (e.g. due to bookmark or refresh)
    // and it has specific non-JSON dependent setup (like quiz init), handle it.
    // However, loadAfsluitingContent if it loads chapter JSON might conflict.
    // Best to have loadAfsluitingContent only do things not covered by hoofdstuk8.json
    const activeSectionElement = document.querySelector('section.active');
    let initialSection = currentSection; // Default to global currentSection
    if (activeSectionElement) {
        const sectionNumAttr = activeSectionElement.getAttribute('data-section');
        if (sectionNumAttr) {
            initialSection = parseInt(sectionNumAttr);
        }
    }
    
    if (initialSection === 8) {
        // If loadContentForSection for section 8 handles all text from JSON,
        // loadAfsluitingContent should only do things like initialize the quiz that are separate.
        // await loadAfsluitingContent(); // This was loading hoofdstuk_afsluiting.json
        // The new loadMCQuiz loads afsluitquiz.json, which is better.
        await loadMCQuiz(); // Load the quiz specific to section 8
    }
    await updateAllChapterProgress(); // Ensure progress is updated after all initial loads.

    // Event handler voor Wis Alle Voortgang knop
    const clearBtn = document.getElementById('clearProgressBtn');
    if (clearBtn) {
        clearBtn.addEventListener('click', clearAllProgress);
    }

    // Showcase expand/collapse all
    const expandAllBtn = document.getElementById('expandAllShowcase');
    const collapseAllBtn = document.getElementById('collapseAllShowcase');
    const showcaseCollapsibles = document.querySelectorAll('.style-guide > .collapsible-section > .collapsible');

    if (expandAllBtn && collapseAllBtn && showcaseCollapsibles.length > 0) {
        expandAllBtn.addEventListener('click', () => {
            showcaseCollapsibles.forEach(collapsible => {
                if (!collapsible.classList.contains('active')) {
                    collapsible.click(); // Simulate a click to trigger the existing logic
                }
            });
        });

        collapseAllBtn.addEventListener('click', () => {
            showcaseCollapsibles.forEach(collapsible => {
                if (collapsible.classList.contains('active')) {
                    collapsible.click(); // Simulate a click to trigger the existing logic
                }
            });
        });
    }

    // Voer migratie uit voordat andere initialisatie
    await migrateOldIdsToNewFormat();
});

// New global function to handle MC answer checking
async function checkMCAnswer(interactionId, selectedAnswer, correctAnswerIndex, sectionNumber, mcElement, allOptions) {
    if (!mcElement || mcElement.classList.contains('answered')) return;

    const isCorrect = selectedAnswer === correctAnswerIndex;
    const feedbackEl = mcElement.querySelector(`#feedback-${interactionId}`);
    
    allOptions.forEach(opt => {
        opt.classList.remove('selected', 'correct', 'incorrect');
        const optId = parseInt(opt.getAttribute('data-id'));
        if (optId === selectedAnswer) {
            opt.classList.add('selected');
            opt.classList.add(isCorrect ? 'correct' : 'incorrect');
        }
        // Optionally, highlight the correct answer if the selection was wrong and different
        // if (!isCorrect && optId === correctAnswerIndex) {
        //     opt.classList.add('correct'); 
        // }
    });

    // Prevent further clicks by adding 'disabled' or removing listener (adding class is simpler for styling)
    allOptions.forEach(opt => opt.style.pointerEvents = 'none'); // Disable pointer events
    mcElement.classList.add('answered');

    // Fetch full interaction data (including feedback text) from JSON
    const fullInteractionData = await getInteractionData(sectionNumber, interactionId);

    if (feedbackEl && fullInteractionData && fullInteractionData.feedback) {
        feedbackEl.textContent = fullInteractionData.feedback;
        feedbackEl.className = 'feedback ' + (isCorrect ? 'correct' : 'incorrect');
    } else if (feedbackEl) { // Fallback basic feedback
        feedbackEl.textContent = isCorrect ? 'Correct!' : 'Incorrect, probeer het nog eens of ga verder.';
        feedbackEl.className = 'feedback ' + (isCorrect ? 'correct' : 'incorrect');
    }

    localStorage.setItem(`mc_${sectionNumber}_${interactionId}_answered`, 'true');
    localStorage.setItem(`mc_${sectionNumber}_${interactionId}_correct`, isCorrect ? '1' : '0');
    localStorage.setItem(`mc_${sectionNumber}_${interactionId}_selected`, selectedAnswer.toString()); // selectedAnswer opslaan!

    await updateAllChapterProgress();
}

// Helper function to get interaction data (needed for feedback messages)
async function getInteractionData(sectionNumber, interactionId) {
    try {
        const res = await fetch(`content/hoofdstuk${sectionNumber}.json`);
        if (!res.ok) return null;
        const chapterData = await res.json();
        return chapterData.interacties.find(i => i.id === interactionId);
    } catch (e) {
        console.error("Error fetching interaction data", e);
        return null;
    }
}

async function clearAllProgress() {
    if (confirm("Weet je zeker dat je alle voortgang wilt wissen? Dit kan niet ongedaan worden gemaakt.")) {
        console.log("Clearing all progress...");
        const keysToClear = [];
        for (let i = 0; i < localStorage.length; i++) {
            const key = localStorage.key(i);
            if (key.startsWith('reflection_') || 
                key.startsWith('mc') || 
                key.startsWith('dragdrop_') || 
                key.startsWith('selfassessment_') || 
                key.startsWith('flashcard_') || // <-- toegevoegd!
                key === 'chapterProgress' ||
                key.endsWith('_answered') || 
                key.endsWith('_correct') || 
                key.endsWith('_done')) {
                keysToClear.push(key);
            }
        }
        
        keysToClear.forEach(key => {
            console.log(`Removing item: ${key}`);
            localStorage.removeItem(key);
        });
        
        document.querySelectorAll('textarea.reflection-input').forEach(ta => ta.value = '');
        
        document.querySelectorAll('.mc-question').forEach(el => {
            if (!el.closest('#quiz-container')) {
                el.classList.remove('answered');
                el.querySelectorAll('.mc-option').forEach(opt => {
                    opt.classList.remove('selected', 'correct', 'incorrect', 'disabled');
                    opt.style.cursor = '';
                });
                const feedbackInMc = el.querySelector('.feedback');
                if (feedbackInMc) {
                    feedbackInMc.textContent = '';
                    feedbackInMc.className = 'feedback';
                }
            }
        });

        document.querySelectorAll('.interactive-exercise[data-dragdrop-id]').forEach(ddExercise => {
            const section = ddExercise.dataset.sectionNumber;
            const id = ddExercise.dataset.dragdropId;
            const containerId = `hoofdstuk${section}-${id}`;
            if (typeof resetDragDrop === 'function') {
                 // Call resetDragDrop to handle UI and specific localStorage for this d&d instance.
                 // resetDragDrop itself will call updateAllChapterProgress, or it should be called after the loop.
                 // For now, let resetDragDrop handle its own update. If progress becomes an issue, we'll revisit.
                 resetDragDrop(parseInt(section), id, containerId); 
            } else {
                const dragContainer = ddExercise.querySelector('.drag-container');
                const dropTargets = ddExercise.querySelectorAll('.drop-target .draggable');
                if (dragContainer && dropTargets) { // Add null checks
                    dropTargets.forEach(item => dragContainer.appendChild(item));
                }
                ddExercise.querySelectorAll('.draggable').forEach(item => item.classList.remove('correct', 'incorrect'));
                const ddFeedback = ddExercise.querySelector('.dragdrop-feedback');
                if(ddFeedback) {
                    ddFeedback.textContent = '';
                    ddFeedback.className = 'dragdrop-feedback';
                }
                const resetButton = ddExercise.querySelector('.btn-reset-dragdrop');
                if(resetButton) resetButton.style.display = 'none';
                const checkButton = ddExercise.querySelector('.btn-check-dragdrop');
                if(checkButton) checkButton.disabled = false;
            }
        });

        document.querySelectorAll('.assessment-select').forEach(sel => sel.value = '');
        
        const quizContainer = document.getElementById('quiz-container');
        if (quizContainer) {
            quizContainer.innerHTML = '<p>De quiz is gereset. Selecteer eventueel opnieuw de Afsluitende sectie om de quiz te starten.</p>';
            quizAnswers = []; 
            currentQuizQuestionIndex = 0;
        }

        console.log("All relevant localStorage items cleared and UI reset.");

        await updateAllChapterProgress(); 
        showSection(1); 
        alert("Alle voortgang is gewist.");
    }
}

async function generatePDF() {
    const { jsPDF } = window.jspdf;
    const doc = new jsPDF({ unit: 'pt', format: 'a4' });
    const pageWidth = doc.internal.pageSize.getWidth();
    const pageHeight = doc.internal.pageSize.getHeight();

    // Marges
    const topMargin = 48;
    const bottomMargin = 48;
    const sideMargin = 48;

    // Load config data
    const config = await fetch('content/config.json').then(r => r.json());

    // --- 1. Voorpagina ---
    const nameInput = document.getElementById('student-name');
    const studentName = nameInput ? nameInput.value.trim() : '';
    if (!studentName) {
        alert('Vul je naam in om het certificaat te genereren.');
        if (nameInput) nameInput.focus();
        return;
    }
    const today = new Date();
    const datum = `${today.getDate()}-${today.getMonth()+1}-${today.getFullYear()}`;

    // Subtiele achtergrondkleur ALLEEN voor de buitenkant van de eerste pagina
    doc.setFillColor('#F8F6FF');
    doc.rect(0, 0, pageWidth, pageHeight, 'F');
    // Witte achtergrond binnen de groene lijn
    doc.setFillColor('#FFFFFF');
    doc.rect(sideMargin, topMargin, pageWidth-2*sideMargin, pageHeight-2*topMargin, 'F');

    // Groene kader
    doc.setDrawColor(config.stijl.primairKleur);
    doc.setLineWidth(2);
    doc.rect(sideMargin, topMargin, pageWidth-2*sideMargin, pageHeight-2*topMargin);

    // --- Rest van de pagina's hebben standaard witte achtergrond ---
    // Verwijder alle eerdere setFillColor('#F8F6FF') en rect(0, 0, pageWidth, pageHeight, 'F') voor andere pagina's

    // Logo's
    const hanLogo = 'images/Blijvende_afb/HAN_logo1a.png';
    const ixLogo = config.logo;
    // Helper voor aspect ratio
    async function addImageToDoc(imgPath, x, y, maxW, maxH, alignCenter = false) {
        return new Promise((resolve) => {
            const img = new window.Image();
            img.onload = function() {
                let w = img.width;
                let h = img.height;
                const ratio = Math.min(maxW / w, maxH / h);
                w = w * ratio;
                h = h * ratio;
                let drawX = x;
                if (alignCenter) drawX = x - w / 2;
                doc.addImage(img, 'PNG', drawX, y, w, h);
                resolve();
            };
            img.src = imgPath;
        });
    }

    // iXperium-logo bovenaan, gecentreerd, groter en met marge tot bovenrand
    const ixLogoMaxW = pageWidth * 0.45;
    const ixLogoMaxH = 80;
    let y = topMargin + 18;
    await addImageToDoc(ixLogo, pageWidth/2, y, ixLogoMaxW, ixLogoMaxH, true);
    y += ixLogoMaxH + 32; // Meer ruimte onder het logo

    // Titel (met automatische regelafbreking)
    doc.setFont('helvetica', 'bold');
    doc.setFontSize(28);
    doc.setTextColor(config.stijl.primairKleur);
    const splitTitle = doc.splitTextToSize(config.titel, pageWidth-2*sideMargin-40);
    doc.text(splitTitle, pageWidth/2, y, { align: 'center' });
    y += splitTitle.length * 28 + 24; // Meer ruimte na de titel

    // Toelichting
    doc.setFont('helvetica', 'normal');
    doc.setFontSize(15);
    doc.setTextColor('#000');
    doc.text('Hierbij wordt verklaard dat', pageWidth/2, y, { align: 'center' });
    y += 28; // Grotere marge na toelichting

    // NAAM - extra groot, vet, met veel witruimte boven en onder
    doc.setFont('helvetica', 'bold');
    doc.setFontSize(28);
    y += 24; // Extra witruimte boven de naam
    doc.text(studentName, pageWidth/2, y, { align: 'center' });
    y += 40; // Extra witruimte onder de naam

    // Ondertekst
    doc.setFont('helvetica', 'normal');
    doc.setFontSize(14);
    doc.text('de e-learning module heeft doorlopen en actief heeft gewerkt aan de leerdoelen op de volgende pagina.', pageWidth/2, y, { align: 'center', maxWidth: pageWidth-2*sideMargin-40 });
    y += 32;

    // Datum netjes boven de ondermarge
    // let dateY = pageHeight - bottomMargin - 70;
    // doc.setFontSize(12);
    // doc.text(`Datum: ${datum}`, pageWidth/2, dateY, { align: 'center' });

    // HAN-logo onderaan, gecentreerd en groot, maar altijd binnen de rand
    const hanLogoMaxW = pageWidth * 0.5;
    const hanLogoMaxH = 60;
    const hanLogoY = pageHeight - bottomMargin - hanLogoMaxH - 18;
    // Datum netjes boven het HAN-logo
    const dateYHan = hanLogoY - 24;
    doc.setFontSize(12);
    doc.text(`Datum: ${datum}`, pageWidth/2, dateYHan, { align: 'center' });
    await addImageToDoc(hanLogo, pageWidth/2, hanLogoY, hanLogoMaxW, hanLogoMaxH, true);

    // Copyright netjes onder het HAN-logo
    doc.setFontSize(10);
    doc.setTextColor('#888');
    doc.text(`© ${new Date().getFullYear()} ${config.organisatie}`, pageWidth/2, pageHeight - bottomMargin + 18, { align: 'center' });
    doc.setTextColor('#000');

    // Variabele voor totaal aantal pagina's, wordt later bijgewerkt
    let totalPagesPlaceholder = 'totalPagesPlaceholder';

    // --- 2. Leerdoelen en reflectie ---
    doc.addPage();
    doc.setFillColor('#FFFFFF');
    doc.rect(0, 0, pageWidth, pageHeight, 'F');
    
    let pageNum = 2;
    let yPos2 = topMargin + 18;
    doc.setFont('helvetica', 'bold');
    doc.setFontSize(18);
    doc.setTextColor(config.stijl.primairKleur);
    doc.text('Leerdoelen bij deze elearning:', sideMargin, yPos2);
    yPos2 += 30;
    doc.setFont('helvetica', 'normal');
    doc.setFontSize(12);
    doc.setTextColor('#000');
    config.leerdoelen.forEach((leerdoel, index) => {
        if (yPos2 > pageHeight-bottomMargin-60) {
            doc.addPage();
            // Subtiele achtergrondkleur voor elke nieuwe pagina
            doc.setFillColor('#FFFFFF');
            doc.rect(0, 0, pageWidth, pageHeight, 'F');
            yPos2 = topMargin + 18;
            pageNum++;
        }
        doc.setFont('helvetica', 'bold');
        doc.text(`Leerdoel ${index + 1}:`, sideMargin, yPos2);
        yPos2 += 15;
        doc.setFont('helvetica', 'normal');
        const split = doc.splitTextToSize(leerdoel, pageWidth-2*sideMargin-20);
        doc.text(split, sideMargin+20, yPos2);
        yPos2 += split.length * 18 + 10;
    });
    doc.setFontSize(9);
    doc.setTextColor('#888');
    doc.text(`Pagina 2 van ${totalPagesPlaceholder}`, pageWidth-sideMargin-10, pageHeight-bottomMargin+8, { align: 'right' });

    // --- 3. Quizoverzicht (afsluitquiz) ---
    doc.addPage();
    doc.setFillColor('#FFFFFF');
    doc.rect(0, 0, pageWidth, pageHeight, 'F');
    
    pageNum = 3;
    let yPos3 = topMargin + 18;
    doc.setFont('helvetica', 'bold');
    doc.setFontSize(18);
    doc.setTextColor(config.stijl.primairKleur);
    doc.text('Afsluitende Quiz: Jouw Antwoorden', sideMargin, yPos3);
    yPos3 += 30;
    doc.setFont('helvetica', 'normal');
    doc.setFontSize(12);
    doc.setTextColor('#222');
    // Laad quizdata en antwoorden
    const afsluitQuiz = await fetch('content/afsluitquiz.json').then(r => r.json());
    const quizAns = JSON.parse(localStorage.getItem('mc_quiz_answers') || '[]');
    afsluitQuiz.forEach((q, idx) => {
        if (yPos3 > pageHeight-bottomMargin-120) { 
            doc.addPage(); 
            // Subtiele achtergrondkleur voor elke nieuwe pagina
            doc.setFillColor('#FFFFFF');
            doc.rect(0, 0, pageWidth, pageHeight, 'F');
            yPos3 = topMargin + 18; 
            pageNum++; 
        }
        // Vraag
        doc.setFont('helvetica', 'bold');
        doc.setFontSize(13);
        doc.setTextColor('#222');
        const splitQ = doc.splitTextToSize(`${idx+1}. ${q.text}`, pageWidth-2*sideMargin-20);
        doc.text(splitQ, sideMargin, yPos3);
        yPos3 += splitQ.length * 16 + 2;
        // Antwoord
        let ans = quizAns.find(a => a.id === q.id);
        let correct = ans && ans.correct;
        let antwoordText = ans ? (q.options[ans.selected-1] || '') : '[Geen antwoord ingevuld]';
        
        // Combineer label en antwoord voor afbreking
        const volledigeAntwoordTekst = `Jouw antwoord: ${antwoordText} (${correct ? 'Goed' : 'Fout'})`;
        const splitA = doc.splitTextToSize(volledigeAntwoordTekst, pageWidth-2*sideMargin-20);
        
        let kleur = correct ? '#e8f5e9' : '#ffebee';
        let textKleur = correct ? '#2e7d32' : '#c62828';
        doc.setFillColor(kleur);
        doc.setDrawColor('#fff');
        doc.rect(sideMargin, yPos3-8, pageWidth-2*sideMargin, splitA.length*18+12, 'F');
        doc.setTextColor(textKleur);
        
        // Teken de afgebroken tekst (vetgedrukt deel wordt nu als normale tekst getekend binnen de afbreking)
        doc.setFont('helvetica', 'normal'); // Kan bold zijn als je dat specifiek instelt per deel
        doc.text(splitA, sideMargin+10, yPos3+8);
        yPos3 += splitA.length * 18 + 18;

        // Juiste antwoord tonen bij fout
        if(ans && !correct && typeof q.correctAnswer === 'number' && q.options && q.options[q.correctAnswer-1]) {
            doc.setFillColor('#ffffff');
            doc.setDrawColor('#28a745');
            const correctAntwoordLabel = 'Correct antwoord: ';
            const correctAntwoordWaarde = q.options[q.correctAnswer-1];
            const volledigeCorrectAntwoordTekst = `${correctAntwoordLabel}${correctAntwoordWaarde}`;
            const splitC = doc.splitTextToSize(volledigeCorrectAntwoordTekst, pageWidth-2*sideMargin-20);
            doc.rect(sideMargin, yPos3-8, pageWidth-2*sideMargin, splitC.length*18+12, 'S');
            doc.setTextColor('#28a745');
            
            doc.setFont('helvetica', 'normal'); // Idem, kan bold zijn als je dat specifiek instelt
            doc.text(splitC, sideMargin+10, yPos3+8);
            yPos3 += splitC.length * 18 + 18;
        }
        // Feedback
        if(q.feedback) {
            doc.setFontSize(11);
            doc.setTextColor('#555');
            const splitF = doc.splitTextToSize(q.feedback, pageWidth-2*sideMargin-20);
            doc.text(splitF, sideMargin+10, yPos3+4);
            yPos3 += splitF.length * 15 + 10;
            doc.setFontSize(12);
        }
        yPos3 += 8;
    });
    doc.setFontSize(9);
    doc.setTextColor('#888');
    doc.text(`Pagina 3 van ${totalPagesPlaceholder}`, pageWidth-sideMargin-10, pageHeight-bottomMargin+8, { align: 'right' });

    // --- 4. Antwoorden per hoofdstuk ---
    // Voor elk hoofdstuk: laad json, toon titel, loop door interacties
    const hoofdstukken = [];
    // Dynamisch hoofdstukken array vullen op basis van totalSections
    // Alle hoofdstukken behalve het laatste (afsluitend hoofdstuk)
    for (let i = 1; i < totalSections; i++) {
        hoofdstukken.push(i);
    }
    for (let h of hoofdstukken) {
        const hoofdstukData = await fetch(`content/hoofdstuk${h}.json`).then(r => r.json());
        doc.addPage();
        doc.setFillColor('#FFFFFF');
        doc.rect(0, 0, pageWidth, pageHeight, 'F');
        
        pageNum++;
        let yH = topMargin + 18;
        doc.setFont('helvetica', 'bold');
        doc.setFontSize(17);
        doc.setTextColor(config.stijl.primairKleur);
        
        // Hoofdstuktitel met automatische regelafbreking om overflow te voorkomen
        const hoofdstukTitel = `Hoofdstuk ${h}: ${hoofdstukData.titel || ''}`;
        const splitHoofdstukTitel = doc.splitTextToSize(hoofdstukTitel, pageWidth-2*sideMargin-20);
        doc.text(splitHoofdstukTitel, sideMargin, yH);
        yH += splitHoofdstukTitel.length * 20 + 8;
        
        if(hoofdstukData.interacties && hoofdstukData.interacties.length > 0) {
            for(const interactie of hoofdstukData.interacties) {
                if (yH > pageHeight-bottomMargin-120) { 
                    doc.addPage(); 
                    // Subtiele achtergrondkleur voor elke nieuwe pagina
                    doc.setFillColor('#FFFFFF');
                    doc.rect(0, 0, pageWidth, pageHeight, 'F');
                    yH = topMargin + 18; 
                    pageNum++; 
                }
                // Vraag
                doc.setFont('helvetica', 'bold');
                doc.setFontSize(13);
                doc.setTextColor('#222');
                const splitQ = doc.splitTextToSize(interactie.vraag || '', pageWidth-2*sideMargin-20);
                doc.text(splitQ, sideMargin, yH);
                yH += splitQ.length * 16 + 2;
                // Antwoord ophalen per type
                let antwoordBlok = '';
                let kleurBlok = '#e3f2fd';
                let textKleurBlok = '#1565c0';
                let feedback = '';
                let juisteAntwoord = '';
                let antwoordBlokTableRows = null;
                if(interactie.type === 'reflection') {
                    let ans = localStorage.getItem(`reflection_${h}_${interactie.id}_answered`) || '[Geen antwoord ingevuld]';
                    // Split en teken "Jouw reflectie:" in bold en de rest normaal
                    const reflectieText = 'Jouw reflectie: ';
                    const restVanReflectie = ans;
                    const volledigeReflectieTekst = reflectieText + restVanReflectie;
                    const splitA_reflectie = doc.splitTextToSize(volledigeReflectieTekst, pageWidth-2*sideMargin-20);
                    doc.setFillColor(kleurBlok);
                    doc.setDrawColor('#fff');
                    doc.rect(sideMargin, yH-8, pageWidth-2*sideMargin, splitA_reflectie.length*18+12, 'F');
                    doc.setTextColor(textKleurBlok);
                    doc.setFont('helvetica', 'normal'); // Kan bold zijn als je dat specifiek instelt
                    doc.text(splitA_reflectie, sideMargin+10, yH+8);
                    yH += splitA_reflectie.length * 18 + 18;
                    continue; // Sla verdere rendering van deze reflectie over
                } else if(interactie.type === 'mc') {
                    let ansSaved = localStorage.getItem(`mc_${h}_${interactie.id}_answered`);
                    let correct = localStorage.getItem(`mc_${h}_${interactie.id}_correct`) === '1';
                    let ansIdx = null;
                    if(ansSaved) {
                        // Gebruik de opgeslagen geselecteerde optie index
                        ansIdx = parseInt(localStorage.getItem(`mc_${h}_${interactie.id}_selected`));
                    }
                    let optie = (ansIdx && interactie.options && interactie.options[ansIdx-1]) ? interactie.options[ansIdx-1] : '[Geen antwoord ingevuld]';
                    
                    const jouwAntwoordLabel = 'Jouw antwoord: ';
                    const jouwAntwoordStatus = ` (${correct ? 'Goed' : 'Fout'})`;
                    const volledigeJouwAntwoordTekst = `${jouwAntwoordLabel}${optie}${jouwAntwoordStatus}`;
                    
                    kleurBlok = correct ? '#e8f5e9' : '#ffebee';
                    textKleurBlok = correct ? '#2e7d32' : '#c62828';
                    const splitA_mc = doc.splitTextToSize(volledigeJouwAntwoordTekst, pageWidth-2*sideMargin-20);
                    doc.setFillColor(kleurBlok);
                    doc.setDrawColor('#fff');
                    doc.rect(sideMargin, yH-8, pageWidth-2*sideMargin, splitA_mc.length*18+12, 'F');
                    doc.setTextColor(textKleurBlok);
                    doc.setFont('helvetica', 'normal'); // Kan bold zijn als je dat specifiek instelt
                    doc.text(splitA_mc, sideMargin+10, yH+8);
                    yH += splitA_mc.length * 18 + 18;

                    if(!correct && typeof interactie.correctAnswer === 'number' && interactie.options && interactie.options[interactie.correctAnswer-1]) {
                        const correctAntwoordLabelPDF = 'Correct antwoord: ';
                        const correctAntwoordWaardePDF = interactie.options[interactie.correctAnswer-1];
                        const volledigeCorrectAntwoordTekstPDF = `${correctAntwoordLabelPDF}${correctAntwoordWaardePDF}`;
                        const splitC_mc = doc.splitTextToSize(volledigeCorrectAntwoordTekstPDF, pageWidth-2*sideMargin-20);
                        doc.setFillColor('#ffffff');
                        doc.setDrawColor('#28a745');
                        doc.rect(sideMargin, yH-8, pageWidth-2*sideMargin, splitC_mc.length*18+12, 'S');
                        doc.setTextColor('#28a745');
                        doc.setFont('helvetica', 'normal'); // Kan bold zijn als je dat specifiek instelt
                        doc.text(splitC_mc, sideMargin+10, yH+8);
                        yH += splitC_mc.length * 18 + 18;
                    }
                    feedback = interactie.feedback || '';
                    yH += 24; // Extra witruimte na MC blok
                    continue;
                } else if(interactie.type === 'dragdrop') {
                    console.log('dragdrop:', {
                        targets: interactie.targets,
                        items: interactie.items,
                        correctCombinations: interactie.correctCombinations
                    });
                    let correct = localStorage.getItem(`dragdrop_${h}_${interactie.id}_correct`) === 'true';
                    if (correct && interactie.targets && interactie.items && interactie.correctCombinations && interactie.targets.length && interactie.items.length && interactie.correctCombinations.length) {
                        // Maak een lookup voor item labels
                        const itemLabelMap = {};
                        interactie.items.forEach(item => { itemLabelMap[item.id] = item.label; });
                        // Bouw tabelrijen
                        const tableRows = interactie.correctCombinations.map(pair => {
                            let target = interactie.targets.find(t => t.id === pair.targetId);
                            let targetLabel = target ? target.label.replace(/<[^>]*>/g, '') : pair.targetId;
                            let itemLabel = itemLabelMap[pair.itemId] || pair.itemId;
                            return { targetLabel, itemLabel };
                        });
                        kleurBlok = '#e8f5e9';
                        textKleurBlok = '#2e7d32';
                        feedback = interactie.feedbackCorrect || '';
                        // Bereken maximale breedtes voor beide kolommen
                        const availableWidth = pageWidth - 2*sideMargin - 40; // Totale beschikbare breedte
                        const columnGap = 20; // Ruimte tussen kolommen
                        const maxColWidth = (availableWidth - columnGap) / 2; // Maximale breedte per kolom

                        // Bereken werkelijke hoogtes voor elke rij
                        const rowHeights = tableRows.map(row => {
                            const leftSplit = doc.splitTextToSize(row.targetLabel, maxColWidth);
                            const rightSplit = doc.splitTextToSize(row.itemLabel, maxColWidth);
                            return Math.max(leftSplit.length, rightSplit.length) * 18; // 18pt per regel
                        });

                        const totalHeight = rowHeights.reduce((sum, h) => sum + h, 0) + 40; // +40 voor header en padding

                        // Teken kader
                        doc.setFillColor(kleurBlok);
                        doc.setDrawColor('#fff');
                        doc.rect(sideMargin, yH-8, pageWidth-2*sideMargin, totalHeight, 'F');
                        
                        // Header
                        doc.setTextColor(textKleurBlok);
                        doc.setFont('helvetica', 'bold');
                        doc.text('Juiste koppelingen:', sideMargin+10, yH+8);
                        doc.setFont('helvetica', 'normal');

                        // Teken rijen
                        let currentY = yH + 28;
                        tableRows.forEach((row, index) => {
                            // Links
                            const leftSplit = doc.splitTextToSize(row.targetLabel, maxColWidth);
                            doc.text(leftSplit, sideMargin+10, currentY);

                            // Rechts
                            const rightSplit = doc.splitTextToSize(row.itemLabel, maxColWidth);
                            doc.text(rightSplit, sideMargin + maxColWidth + columnGap + 10, currentY);

                            currentY += rowHeights[index] + 5; // 5pt extra ruimte tussen rijen
                        });

                        yH += totalHeight + 10;
                    } else {
                        let antwoordBlok = correct ? 'Alle koppelingen zijn correct, maar de data voor de tabel ontbreekt.' : 'Niet alle koppelingen zijn correct.';
                        kleurBlok = correct ? '#e8f5e9' : '#ffebee';
                        textKleurBlok = correct ? '#2e7d32' : '#c62828';
                        feedback = correct ? (interactie.feedbackCorrect || '') : (interactie.feedbackIncorrect || '');
                        const splitA = doc.splitTextToSize(antwoordBlok, pageWidth-2*sideMargin-20);
                        doc.setFillColor(kleurBlok);
                        doc.setDrawColor('#fff');
                        doc.rect(sideMargin, yH-8, pageWidth-2*sideMargin, splitA.length*18+12, 'F');
                        doc.setTextColor(textKleurBlok);
                        doc.setFont('helvetica', 'normal');
                        doc.text(splitA, sideMargin+10, yH+8);
                        yH += splitA.length * 18 + 18;
                    }
                } else if(interactie.type === 'selfassessment') {
                    let ans = localStorage.getItem(`selfassessment_${h}_${interactie.id}_done`);
                    // Dynamische mapping voor betekenis
                    const niveauLabels = { '1': 'Beginnend', '2': 'In ontwikkeling', '3': 'Bekwaam' };
                    const competenties = ['Veranderen', 'Vinden', 'Vertrouwen', 'Vaardig gebruiken', 'Vertellen'];
                    if(ans) {
                        try {
                            let obj = JSON.parse(ans);
                            kleurBlok = '#fffbe0'; textKleurBlok = '#b8860b';
                            // Bereken hoogte nauwkeuriger: 1 regel voor titel + 1 per competentie
                            let regels = 1 + competenties.length;
                            const hoogte = regels * 22 + 8; // minder extra ruimte
                            // Teken kader
                            doc.setFillColor(kleurBlok);
                            doc.setDrawColor('#fff');
                            doc.rect(sideMargin, yH-8, pageWidth-2*sideMargin, hoogte, 'F');
                            doc.setTextColor(textKleurBlok);
                            // Titel vet
                            doc.setFont('helvetica', 'bold');
                            doc.text('Jouw zelfbeoordeling:', sideMargin+10, yH+8);
                            let yCurrent = yH+8+22;
                            // Elke competentie onder elkaar, met bullet, naam vet, niveau normaal
                            competenties.forEach(comp => {
                                doc.setFont('helvetica', 'bold');
                                const compText = '\u2022 ' + comp + ':';
                                doc.text(compText, sideMargin+10, yCurrent); // Bullet + competentie
                                // Meet breedte in bold
                                const compWidth = doc.getTextWidth(compText);
                                doc.setFont('helvetica', 'normal');
                                let waarde = obj[comp.toLowerCase().replace(' ', '')] || obj[comp] || '';
                                let betekenis = niveauLabels[waarde] || '[Niet ingevuld]';
                                doc.text(betekenis, sideMargin+10+compWidth+4, yCurrent); // 4pt extra ruimte
                                yCurrent += 22;
                            });
                            yH += hoogte + 10;
                        } catch {}
                    } else {
                        antwoordBlok = '[Geen antwoord ingevuld]';
                        kleurBlok = '#fffde7'; textKleurBlok = '#f9a825';
                        const splitA = doc.splitTextToSize(antwoordBlok, pageWidth-2*sideMargin-20);
                        doc.setFillColor(kleurBlok);
                        doc.setDrawColor('#fff');
                        doc.rect(sideMargin, yH-8, pageWidth-2*sideMargin, splitA.length*18+12, 'F');
                        doc.setTextColor(textKleurBlok);
                        doc.setFont('helvetica', 'normal');
                        doc.text(splitA, sideMargin+10, yH+8);
                        yH += splitA.length * 18 + 24;
                    }
                    continue;
                } else if(interactie.type === 'critical_analysis') {
                    let ans = localStorage.getItem(`critical_analysis_${h}_${interactie.id}_answered`);
                    if(ans) {
                        try {
                            let obj = JSON.parse(ans);
                            // Toon elk veld met subtitel, titels vet
                            let yStart = yH;
                            let analyseTitel = 'Jouw analyse:';
                            kleurBlok = '#e3f2fd'; // Lichte blauwe achtergrond
                            textKleurBlok = '#1565c0'; // Donkerblauwe tekst
                            doc.setFillColor(kleurBlok);
                            doc.setDrawColor('#fff');
                            // Bepaal voorlopige hoogte
                            let yCurrent = yH+8+18;
                            let totalLines = 1;
                            let maxWidth = pageWidth-2*sideMargin-20;
                            // Bepaal breedte van de langste subtitel
                            const labels = ['Technologie: ', 'Sterke punten: ', 'Uitdagingen: ', 'Implementatie: '];
                            let maxLabelWidth = Math.max(...labels.map(l => doc.getTextWidth(l)));
                            // Bereken hoogte voor alle velden
                            if(obj.technologie) {
                                const techLabel = 'Technologie: ';
                                const splitTech = doc.splitTextToSize(obj.technologie, maxWidth-maxLabelWidth);
                                totalLines += splitTech.length;
                                yCurrent += splitTech.length * 18 + 6;
                            }
                            if(obj.sterkePunten) {
                                const sterkeLabel = 'Sterke punten: ';
                                const splitSterke = doc.splitTextToSize(obj.sterkePunten, maxWidth-maxLabelWidth);
                                totalLines += splitSterke.length;
                                yCurrent += splitSterke.length * 18 + 6;
                            }
                            if(obj.uitdagingen) {
                                const uitdagingenLabel = 'Uitdagingen: ';
                                const splitUitdagingen = doc.splitTextToSize(obj.uitdagingen, maxWidth-maxLabelWidth);
                                totalLines += splitUitdagingen.length;
                                yCurrent += splitUitdagingen.length * 18 + 6;
                            }
                            if(obj.implementatie) {
                                const implementatieLabel = 'Implementatie: ';
                                const splitImpl = doc.splitTextToSize(obj.implementatie, maxWidth-maxLabelWidth);
                                totalLines += splitImpl.length;
                                yCurrent += splitImpl.length * 18 + 6;
                            }
                            const totaleHoogte = yCurrent - yH + 10;
                            doc.setFillColor(kleurBlok);
                            doc.setDrawColor('#fff');
                            doc.rect(sideMargin, yH-8, pageWidth-2*sideMargin, totaleHoogte, 'F');
                            doc.setTextColor(textKleurBlok);
                            doc.setFont('helvetica', 'bold');
                            doc.text(analyseTitel, sideMargin+10, yH+8);
                            yCurrent = yH+8+18;
                            doc.setFont('helvetica', 'normal');
                            if(obj.technologie) {
                                const techLabel = 'Technologie: ';
                                doc.setFont('helvetica', 'bold');
                                doc.text(techLabel, sideMargin+10, yCurrent);
                                doc.setFont('helvetica', 'normal');
                                const splitTech = doc.splitTextToSize(obj.technologie, maxWidth-maxLabelWidth);
                                doc.text(splitTech, sideMargin+10+maxLabelWidth, yCurrent);
                                yCurrent += splitTech.length * 18 + 6;
                            }
                            if(obj.sterkePunten) {
                                const sterkeLabel = 'Sterke punten: ';
                                doc.setFont('helvetica', 'bold');
                                doc.text(sterkeLabel, sideMargin+10, yCurrent);
                                doc.setFont('helvetica', 'normal');
                                const splitSterke = doc.splitTextToSize(obj.sterkePunten, maxWidth-maxLabelWidth);
                                doc.text(splitSterke, sideMargin+10+maxLabelWidth, yCurrent);
                                yCurrent += splitSterke.length * 18 + 6;
                            }
                            if(obj.uitdagingen) {
                                const uitdagingenLabel = 'Uitdagingen: ';
                                doc.setFont('helvetica', 'bold');
                                doc.text(uitdagingenLabel, sideMargin+10, yCurrent);
                                doc.setFont('helvetica', 'normal');
                                const splitUitdagingen = doc.splitTextToSize(obj.uitdagingen, maxWidth-maxLabelWidth);
                                doc.text(splitUitdagingen, sideMargin+10+maxLabelWidth, yCurrent);
                                yCurrent += splitUitdagingen.length * 18 + 6;
                            }
                            if(obj.implementatie) {
                                const implementatieLabel = 'Implementatie: ';
                                doc.setFont('helvetica', 'bold');
                                doc.text(implementatieLabel, sideMargin+10, yCurrent);
                                doc.setFont('helvetica', 'normal');
                                const splitImpl = doc.splitTextToSize(obj.implementatie, maxWidth-maxLabelWidth);
                                doc.text(splitImpl, sideMargin+10+maxLabelWidth, yCurrent);
                                yCurrent += splitImpl.length * 18 + 6;
                            }
                            yH += totaleHoogte + 24; // Extra witruimte na blok
                        } catch {}
                    } else {
                        antwoordBlok = '[Geen antwoord ingevuld]';
                        kleurBlok = '#ede7f6'; textKleurBlok = '#6a1b9a';
                        const splitA = doc.splitTextToSize(antwoordBlok, pageWidth-2*sideMargin-20);
                        doc.setFillColor(kleurBlok);
                        doc.setDrawColor('#fff');
                        doc.rect(sideMargin, yH-8, pageWidth-2*sideMargin, splitA.length*18+12, 'F');
                        doc.setTextColor(textKleurBlok);
                        doc.setFont('helvetica', 'normal');
                        doc.text(splitA, sideMargin+10, yH+8);
                        yH += splitA.length * 18 + 24; // Extra witruimte na blok
                    }
                    continue;
                } else if(interactie.type === 'flashcard') {
                    // Haal flashcard data uit localStorage
                    const baseId = `flashcard_${h}_${interactie.id}`;
                    let herhalingen = {};
                    try { herhalingen = JSON.parse(localStorage.getItem(`${baseId}_herhalingen`) || '{}'); } catch {}
                    let laatsteSet = [];
                    try { laatsteSet = JSON.parse(localStorage.getItem(`${baseId}_laatsteSet`) || '[]'); } catch {}
                    let laatsteType = localStorage.getItem(`${baseId}_laatsteType`) || 'all';
                    let setAfgerond = localStorage.getItem(`${baseId}_setAfgerond`) === 'true';
                    let run = parseInt(localStorage.getItem(`${baseId}_run`) || '1');
                    // Per kaart: voorkant, achterkant, laatste antwoord, aantal keer gedaan
                    const kaarten = interactie.cards || [];
                    if (kaarten.length > 0) {
                        // Tabel header
                        const col1 = 'Voorzijde';
                        const col2 = 'Achterzijde';
                        const col3 = 'Laatste antwoord';
                        const col4 = 'Aantal keer gedaan';
                        const tableWidth = pageWidth-2*sideMargin-20;
                        const colPx = [0, 0, 0, 0];
                        colPx[0] = Math.round(tableWidth * 0.28);
                        colPx[1] = Math.round(tableWidth * 0.38);
                        colPx[2] = Math.round(tableWidth * 0.18);
                        colPx[3] = Math.round(tableWidth * 0.12);
                        let yTable = yH;
                        // Header: bepaal benodigde hoogte per kolom
                        const headerLines = [
                            doc.splitTextToSize(col1, colPx[0]-10),
                            doc.splitTextToSize(col2, colPx[1]-10),
                            doc.splitTextToSize(col3, colPx[2]-10),
                            doc.splitTextToSize(col4, colPx[3]-10)
                        ];
                        const maxHeaderLines = Math.max(...headerLines.map(lines => lines.length));
                        const headerHeight = maxHeaderLines * 14 + 10; // 14pt per regel, 10pt extra padding
                        // Header tekenen
                        doc.setFillColor('#ede7f6');
                        doc.setDrawColor('#8A4A9E');
                        doc.rect(sideMargin, yTable, tableWidth, headerHeight, 'F');
                        doc.setFont('helvetica', 'bold');
                        doc.setFontSize(12);
                        doc.setTextColor('#662483');
                        doc.text(headerLines[0], sideMargin+8, yTable+16, {maxWidth: colPx[0]-10});
                        doc.text(headerLines[1], sideMargin+colPx[0]+8, yTable+16, {maxWidth: colPx[1]-10});
                        doc.text(headerLines[2], sideMargin+colPx[0]+colPx[1]+8, yTable+16, {maxWidth: colPx[2]-10});
                        doc.text(headerLines[3], sideMargin+colPx[0]+colPx[1]+colPx[2]+8, yTable+16, {maxWidth: colPx[3]-10});
                        yTable += headerHeight;
                        doc.setFont('helvetica', 'normal');
                        doc.setFontSize(11);
                        doc.setTextColor('#222');
                        // Rijen
                        kaarten.forEach((kaart, idx) => {
                            // Tekst splitsen per kolom
                            const voorzijdeLines = doc.splitTextToSize(kaart.voorzijde, colPx[0]-10);
                            const achterzijdeLines = doc.splitTextToSize(kaart.achterzijde, colPx[1]-10);
                            let laatsteAntw = '-';
                            let aantal = herhalingen[idx] ? herhalingen[idx] : 1;
                            if (setAfgerond && laatsteType === 'incorrect' && laatsteSet.includes(idx)) {
                                laatsteAntw = 'Ik wist het niet';
                            } else if (setAfgerond) {
                                laatsteAntw = 'Ik wist het';
                            } else {
                                laatsteAntw = '-';
                            }
                            const laatsteAntwLines = doc.splitTextToSize(laatsteAntw, colPx[2]-10);
                            const aantalLines = [aantal.toString()];
                            // Bepaal het max aantal regels voor deze rij
                            const maxLines = Math.max(voorzijdeLines.length, achterzijdeLines.length, laatsteAntwLines.length, aantalLines.length);
                            const rowHeight = maxLines * 14 + 10; // 14pt per regel, 10pt extra padding
                            if (yTable > pageHeight-bottomMargin-rowHeight-20) {
                                doc.addPage();
                                doc.setFillColor('#FFFFFF');
                                doc.rect(0, 0, pageWidth, pageHeight, 'F');
                                yTable = topMargin + 18;
                            }
                            // Rij tekenen
                            doc.setFillColor('#f8f9fa');
                            doc.setDrawColor('#e9ecef');
                            doc.rect(sideMargin, yTable, tableWidth, rowHeight, 'F');
                            doc.setTextColor('#222');
                            // Tekst per kolom verticaal uitlijnen bovenaan
                            doc.text(voorzijdeLines, sideMargin+8, yTable+16, {maxWidth: colPx[0]-10});
                            doc.text(achterzijdeLines, sideMargin+colPx[0]+8, yTable+16, {maxWidth: colPx[1]-10});
                            doc.text(laatsteAntwLines, sideMargin+colPx[0]+colPx[1]+8, yTable+16, {maxWidth: colPx[2]-10});
                            doc.text(aantalLines, sideMargin+colPx[0]+colPx[1]+colPx[2]+8, yTable+16, {maxWidth: colPx[3]-10});
                            yTable += rowHeight;
                        });
                        yH = yTable + 20; // Extra witruimte onder de tabel
                        continue;
                    }
                }
                // Antwoordblok
                const splitA = doc.splitTextToSize(antwoordBlok || '', pageWidth-2*sideMargin-20);
                doc.setFillColor(kleurBlok);
                doc.setDrawColor('#fff');
                doc.rect(sideMargin, yH-8, pageWidth-2*sideMargin, (antwoordBlokTableRows ? (antwoordBlokTableRows.length*18+38) : (splitA.length*18+12)), 'F');
                doc.setTextColor(textKleurBlok);
                doc.setFont('helvetica', 'normal');
                if (antwoordBlokTableRows) {
                    // Tabel header
                    doc.text('Juiste koppelingen:', sideMargin+10, yH+8);
                    let rowY = yH+28;
                    const leftColWidth = Math.max(...antwoordBlokTableRows.map(r => doc.getTextWidth(r.targetLabel))) + 10;
                    const rightColStart = sideMargin + leftColWidth + 30;
                    antwoordBlokTableRows.forEach(row => {
                        doc.text(row.targetLabel, sideMargin+10, rowY, { maxWidth: leftColWidth });
                        doc.text(row.itemLabel, rightColStart, rowY, { maxWidth: pageWidth - rightColStart - sideMargin - 10 });
                        rowY += 18;
                    });
                    yH += 28 + antwoordBlokTableRows.length * 18;
                } else {
                    doc.text(splitA, sideMargin+10, yH+8);
                    yH += splitA.length * 18 + 18;
                }
                // Juiste antwoord (indien van toepassing)
                if(juisteAntwoord) {
                    const splitC = doc.splitTextToSize(juisteAntwoord, pageWidth-2*sideMargin-20);
                    doc.setFillColor('#ffffff');
                    doc.setDrawColor('#28a745');
                    doc.rect(sideMargin, yH-8, pageWidth-2*sideMargin, splitC.length*18+12, 'S');
                    doc.setTextColor('#28a745');
                    doc.text(splitC, sideMargin+10, yH+8);
                    yH += splitC.length * 18 + 18;
                }
                // Feedback (indien aanwezig)
                if(feedback) {
                    // Teken feedback in groen kader
                    const splitF = doc.splitTextToSize(feedback, pageWidth-2*sideMargin-20);
                    const feedbackHoogte = splitF.length * 18 + 12;
                    doc.setFillColor('#e8f5e9');
                    doc.setDrawColor('#fff');
                    doc.rect(sideMargin, yH-8, pageWidth-2*sideMargin, feedbackHoogte, 'F');
                    doc.setTextColor('#2e7d32');
                    doc.setFont('helvetica', 'normal');
                    doc.text(splitF, sideMargin+10, yH+8);
                    yH += feedbackHoogte + 10;
                }
                yH += 10;
            }
        } else {
            doc.setFont('helvetica', 'normal');
            doc.setFontSize(12);
            doc.setTextColor('#888');
            doc.text('Geen interacties in dit hoofdstuk.', sideMargin, yH);
        }
        doc.setFontSize(9);
        doc.setTextColor('#888');
        doc.text(`Pagina ${pageNum} van ${totalPagesPlaceholder}`, pageWidth-sideMargin-10, pageHeight-bottomMargin+8, { align: 'right' });
    }

    // Update totaal aantal pagina's en vervang placeholder in alle voetteksten
    const totalActualPages = doc.getNumberOfPages();
    for (let i = 2; i <= totalActualPages; i++) { // Begin vanaf pagina 2
        doc.setPage(i);
        doc.setFontSize(9);
        doc.setTextColor('#888');
        // Tekst opnieuw schrijven om de placeholder te overschrijven
        doc.setFillColor('#FFFFFF'); // Witte kleur
        doc.rect(pageWidth - sideMargin - 70, pageHeight - bottomMargin, 70, 12, 'F'); // Wit vlak over oude paginanummering

        doc.text(`Pagina ${i} van ${totalActualPages}`, pageWidth-sideMargin-10, pageHeight-bottomMargin+8, { align: 'right' });
    }

    // --- 4. Downloaden ---
    // Bestandsnaam: certificaat_NAAM_TITEL.pdf
    let safeName = studentName.replace(/\s+/g, '_').replace(/[^a-zA-Z0-9_\-]/g, '');
    let safeTitle = config.titel.replace(/\s+/g, '_').replace(/[^a-zA-Z0-9_\-]/g, '');
    if (safeTitle.length > 40) safeTitle = safeTitle.substring(0, 40);
    doc.save(`certificaat_${safeName}_${safeTitle}.pdf`);
}

async function loadAfsluitingContent() {
    try {
        const res = await fetch('content/hoofdstuk_afsluiting.json');
        if (!res.ok) throw new Error('Afsluitend hoofdstuk JSON niet gevonden of laden mislukt');
        const data = await res.json();
        if (data.titel) {
            const titelEl = document.getElementById('afsluiting-titel');
            if (titelEl) titelEl.textContent = data.titel;
        }
        if (data.intro) {
            const introEl = document.getElementById('afsluiting-intro');
            if (introEl) introEl.textContent = data.intro;
        }
        if (data.uitleg) {
            const uitlegEl = document.getElementById('afsluiting-uitleg');
            if (uitlegEl) uitlegEl.textContent = data.uitleg;
        }
        if (data.certificaatUitleg) {
            const certEl = document.getElementById('afsluiting-certificaat');
            if (certEl) certEl.textContent = data.certificaatUitleg;
        }
        if (data.portfolioTip) {
            const tipEl = document.getElementById('afsluiting-portfolio-tip');
            if (tipEl) tipEl.textContent = data.portfolioTip;
        }
    } catch (e) {
        console.error('Fout bij laden van afsluitend hoofdstuk:', e);
    }
}

// Reinstated Drag and Drop functions
function initializeSpecificDragDrop(containerSelector, sectionNumber, dragDropId, correctCombinations) {
    const container = document.getElementById(containerSelector);
    if (!container) {
        console.error(`DragDrop container #${containerSelector} not found in initializeSpecificDragDrop.`);
        return;
    }
    const draggables = container.querySelectorAll('.draggable');
    const dropTargets = container.querySelectorAll('.drop-target');
    
    draggables.forEach(draggable => {
        draggable.addEventListener('dragstart', function (e) {
            e.dataTransfer.setData('text/plain', this.getAttribute('data-id'));
            setTimeout(() => this.classList.add('dragging'), 0);
        });
        draggable.addEventListener('dragend', function () {
            this.classList.remove('dragging');
        });
    });

    dropTargets.forEach(target => {
        target.addEventListener('dragover', function (e) {
            e.preventDefault();
            this.classList.add('dragover');
        });
        target.addEventListener('dragleave', function () {
            this.classList.remove('dragover');
        });
        target.addEventListener('drop', function (e) {
            e.preventDefault();
            this.classList.remove('dragover');
            const draggedId = e.dataTransfer.getData('text/plain');
            // Important: Ensure the draggableElement is sought within the specific drag-drop instance (container)
            const draggableElement = container.querySelector(`.draggable[data-id="${draggedId}"]`);
            if (draggableElement) {
                const existingDraggable = target.querySelector('.draggable');
                if (existingDraggable && existingDraggable !== draggableElement) {
                    // Return to the general drag container within this specific D&D instance
                    container.querySelector('.drag-container').appendChild(existingDraggable);
                }
                target.appendChild(draggableElement);
            }
        });
    });
    
    const dragContainer = container.querySelector('.drag-container');
    if (dragContainer) {
        dragContainer.addEventListener('dragover', function(e) {
            e.preventDefault();
            this.classList.add('dragover');
        });
        dragContainer.addEventListener('dragleave', function() {
            this.classList.remove('dragover');
        });
        dragContainer.addEventListener('drop', function(e) {
            e.preventDefault();
            this.classList.remove('dragover');
            const draggedId = e.dataTransfer.getData('text/plain');
            // Ensure we're only moving draggables that belong to this exercise
            const draggableElement = document.querySelector(`.draggable[data-id="${draggedId}"]`);
            if (draggableElement && draggableElement.closest('.interactive-exercise') === container.querySelector('.interactive-exercise')) {
                this.appendChild(draggableElement);
            }
        });
    }
}

async function checkDragDrop(containerTargetId, sectionNumber, dragDropId) {
    const container = document.getElementById(containerTargetId);
    if(!container) {
      console.error(`DragDrop container #${containerTargetId} not found in checkDragDrop.`);
      return;
    }
    
    const chapterRes = await fetch(`content/hoofdstuk${sectionNumber}.json`);
    if (!chapterRes.ok) {
        console.error(`Failed to fetch chapter data for section ${sectionNumber} in checkDragDrop`);
        return;
    }
    const chapterJson = await chapterRes.json();
    const ddData = chapterJson.interacties.find(i => i.id === dragDropId);

    if (!ddData || !ddData.correctCombinations) {
        console.error(`Drag & drop data or correctCombinations not found for ${dragDropId} in hoofdstuk${sectionNumber}.json`);
        return;
    }

    let correctMap = {};
    if (Array.isArray(ddData.correctCombinations)) {
        ddData.correctCombinations.forEach(pair => {
            correctMap[pair.targetId] = pair.itemId;
        });
    } else {
        correctMap = ddData.correctCombinations;
    }

    let allCorrect = true;
    let placedCount = 0;
    const interactiveExercise = container.querySelector('.interactive-exercise');
    const dropTargets = interactiveExercise.querySelectorAll('.drop-target');
    const currentDropState = [];

    dropTargets.forEach(target => {
        const targetZoneId = target.getAttribute('data-id');
        const draggableElement = target.querySelector('.draggable');
        if (draggableElement) {
            placedCount++;
            const draggableItemId = draggableElement.getAttribute('data-id');
            currentDropState.push({ targetId: targetZoneId, itemId: draggableItemId }); // Sla de huidige plaatsing op
            if (correctMap[targetZoneId] === draggableItemId) {
                draggableElement.classList.add('correct');
                draggableElement.classList.remove('incorrect');
            } else {
                allCorrect = false;
                draggableElement.classList.add('incorrect');
                draggableElement.classList.remove('correct');
            }
        } else {
            if (Object.keys(correctMap).includes(targetZoneId)) {
                 allCorrect = false;
            }
        }
    });
    const initialItemsData = JSON.parse(interactiveExercise.dataset.initialItems || '[]');
    const totalDraggableItems = initialItemsData.length;
    if (placedCount < totalDraggableItems) {
        allCorrect = false;
    }
    const itemsInDragContainer = interactiveExercise.querySelectorAll('.drag-container .draggable');
    if (itemsInDragContainer.length > 0) {
        allCorrect = false;
    }
    const feedbackEl = interactiveExercise.querySelector(`#feedback-${sectionNumber}-${dragDropId}`);
    const resetButton = interactiveExercise.querySelector('.btn-reset-dragdrop');
    const checkButton = interactiveExercise.querySelector('.btn-check-dragdrop');
    
    const storageKeyCorrect = `dragdrop_${sectionNumber}_${dragDropId}_correct`;
    const storageKeyState = `dragdrop_${sectionNumber}_${dragDropId}_state`;

    if (allCorrect) {
        if(feedbackEl) {
            feedbackEl.textContent = ddData.feedbackCorrect || 'Goed gedaan! Alles is correct.';
            feedbackEl.className = 'dragdrop-feedback correct';
        }
        localStorage.setItem(storageKeyCorrect, 'true');
        localStorage.setItem(storageKeyState, JSON.stringify(currentDropState)); // Sla de succesvolle staat op
        if (resetButton) resetButton.style.display = 'none';
        if (checkButton) {
            checkButton.disabled = true;
            checkButton.textContent = 'Opgeslagen';
            checkButton.classList.add('btn-opgeslagen');
        }
        // Maak alle draggables en targets niet meer interactief
        interactiveExercise.querySelectorAll('.draggable').forEach(el => el.setAttribute('draggable', 'false'));
        // Event listeners moeten mogelijk ook worden verwijderd of gecontroleerd.
    } else {
        if(feedbackEl) {
            feedbackEl.textContent = ddData.feedbackIncorrect || 'Niet alle koppelingen zijn correct. Probeer het opnieuw.';
            feedbackEl.className = 'dragdrop-feedback incorrect';
        }
        localStorage.removeItem(storageKeyCorrect);
        localStorage.removeItem(storageKeyState); // Verwijder state als het niet correct is
        if (resetButton) resetButton.style.display = 'inline-block';
        if (checkButton) checkButton.disabled = false;
    }
    await updateAllChapterProgress();
}

function resetDragDrop(sectionNumber, dragDropId, containerTargetId) {
    const container = document.getElementById(containerTargetId); // This is the placeholder div
    if (!container) {
        console.error(`DragDrop placeholder container #${containerTargetId} not found in resetDragDrop.`);
        return;
    }
    const interactiveExercise = container.querySelector('.interactive-exercise'); // Get the actual exercise div
    if (!interactiveExercise) {
        console.error(`DragDrop interactive exercise not found within #${containerTargetId}.`);
        return;
    }

    const dragContainer = interactiveExercise.querySelector('.drag-container');
    const dropTargets = interactiveExercise.querySelectorAll('.drop-target');
    const feedbackEl = interactiveExercise.querySelector(`#feedback-${sectionNumber}-${dragDropId}`);
    const resetButton = interactiveExercise.querySelector('.btn-reset-dragdrop');
    const checkButton = interactiveExercise.querySelector('.btn-check-dragdrop');
    
    if (!dragContainer) {
        console.error("Drag container not found in resetDragDrop for " + containerTargetId);
        return;
    }
    dragContainer.innerHTML = ''; // Clear it first

    // Clear items from drop targets by clearing their innerHTML for .dropped-items-container
    dropTargets.forEach(target => {
        const droppedItemsContainer = target.querySelector('.dropped-items-container');
        if (droppedItemsContainer) {
            droppedItemsContainer.innerHTML = '';
        }
    });
    
    const initialItemsString = interactiveExercise.dataset.initialItems;
    if (initialItemsString) {
        const initialItemsData = JSON.parse(initialItemsString);
        if(initialItemsData.length > 0) {
            initialItemsData.forEach(itemData => {
                const el = document.createElement('div');
                el.className = 'draggable';
                el.setAttribute('draggable', 'true');
                el.setAttribute('data-id', itemData.id);
                el.textContent = itemData.label;
                // Verwijder inline styles die door opslaan zijn toegevoegd
                el.style.pointerEvents = ''; 
                el.style.opacity = '';
                dragContainer.appendChild(el);
            });
            initializeSpecificDragDrop(container.id, sectionNumber, dragDropId, {}); 
        }
    } 
    // Fallback is niet meer echt nodig als dataset.initialItems goed gevuld wordt

    if (feedbackEl) {
        feedbackEl.textContent = '';
        feedbackEl.className = 'dragdrop-feedback';
    }
    if (resetButton) resetButton.style.display = 'none';
    if (checkButton) {
        checkButton.disabled = false;
    }

    localStorage.removeItem(`dragdrop_${sectionNumber}_${dragDropId}_correct`);
    localStorage.removeItem(`dragdrop_${sectionNumber}_${dragDropId}_state`); // Verwijder ook de state
    updateAllChapterProgress(); 
}

// Migratie functie voor oude ID's naar nieuwe format
async function migrateOldIdsToNewFormat() {
    const oldToNewIdMap = {};
    // Dynamisch genereren van chaptersToMigrate op basis van totalSections
    // Alle hoofdstukken behalve het laatste (afsluitend hoofdstuk)
    const chaptersToMigrate = Array.from({length: totalSections - 1}, (_, i) => i + 1);

    // Verzamel alle oude ID's en maak nieuwe
    for (const h of chaptersToMigrate) {
        try {
            const res = await fetch(`content/hoofdstuk${h}.json`);
            if (!res.ok) continue;
            const data = await res.json();
            if (!data.interacties) continue;

            data.interacties.forEach((interactie, index) => {
                const oldId = interactie.id;
                const newId = `h${h}_${interactie.type}_${index + 1}`;
                oldToNewIdMap[oldId] = newId;
            });
        } catch (e) {
            console.error(`Fout bij migreren hoofdstuk ${h}:`, e);
        }
    }

    // Migreer localStorage items
    const keysToMigrate = [];
    for (let i = 0; i < localStorage.length; i++) {
        const key = localStorage.key(i);
        if (key.startsWith('reflection_') || 
            key.startsWith('mc_') || 
            key.startsWith('dragdrop_') || 
            key.startsWith('selfassessment_') || 
            key.startsWith('flashcard_')) {
            keysToMigrate.push(key);
        }
    }

    // Migreer elke key
    keysToMigrate.forEach(oldKey => {
        const value = localStorage.getItem(oldKey);
        if (!value) return;

        // Bepaal het type en hoofdstuk uit de key
        const [type, section, oldId] = oldKey.split('_');
        if (!oldId || !oldToNewIdMap[oldId]) return;

        // Maak nieuwe key met nieuw ID
        const newKey = `${type}_${section}_${oldToNewIdMap[oldId]}`;
        
        // Sla op met nieuwe key
        localStorage.setItem(newKey, value);
        
        // Verwijder oude key niet direct, voor veiligheid
        console.log(`Migrated ${oldKey} to ${newKey}`);
    });
}

// Voeg migratie toe aan DOMContentLoaded
document.addEventListener('DOMContentLoaded', async function() {
    // Voer migratie uit voordat andere initialisatie
    await migrateOldIdsToNewFormat();
    
    // ... existing DOMContentLoaded code ...
});

// Functie om JSON bestanden te updaten met nieuwe ID's
async function updateJsonFilesWithNewIds() {
    // Dynamisch genereren van chaptersToUpdate op basis van totalSections
    // Alle hoofdstukken behalve het laatste (afsluitend hoofdstuk)
    const chaptersToUpdate = Array.from({length: totalSections - 1}, (_, i) => i + 1);
    
    for (const h of chaptersToUpdate) {
        try {
            const res = await fetch(`content/hoofdstuk${h}.json`);
            if (!res.ok) continue;
            const data = await res.json();
            if (!data.interacties) continue;

            // Update interactie ID's
            data.interacties.forEach((interactie, index) => {
                interactie.id = `h${h}_${interactie.type}_${index + 1}`;
            });

            // Sla het bestand op
            const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
            const formData = new FormData();
            formData.append('file', blob, `hoofdstuk${h}.json`);
            
            // Note: Dit vereist een server-side endpoint om het bestand op te slaan
            // Voor nu loggen we alleen de nieuwe structuur
            console.log(`Updated hoofdstuk${h}.json:`, data);
        } catch (e) {
            console.error(`Fout bij updaten hoofdstuk ${h}:`, e);
        }
    }
}

// Voeg update toe aan DOMContentLoaded
document.addEventListener('DOMContentLoaded', async function() {
    // Voer migratie uit voordat andere initialisatie
    await migrateOldIdsToNewFormat();
    
    // Update JSON bestanden met nieuwe ID's
    await updateJsonFilesWithNewIds();
    
    // ... existing DOMContentLoaded code ...
});

// Function to initialize MC interactions (called from dynamicContent.js)
function initializeMCInteraction(containerId, interactionData, sectionNumber) {
    const mcContainer = document.getElementById(containerId);
    if (!mcContainer) {
        console.error(`MC container #${containerId} not found for initialization.`);
        return;
    }
    const options = mcContainer.querySelectorAll('li.mc-option');
    const mcElement = mcContainer.querySelector('.mc-interaction'); // This is the element with id like 'mc-reflection1'

    options.forEach(option => {
        option.addEventListener('click', async function () {
            if (mcElement && mcElement.classList.contains('answered')) return;

            const selectedAnswerValue = parseInt(this.getAttribute('data-id'));
            // Call checkMCAnswer with the necessary details
            await checkMCAnswer(interactionData.id, selectedAnswerValue, interactionData.correctAnswer, sectionNumber, mcElement, options);
        });
    });
}

async function saveCriticalAnalysis(sectionNumber, interactionId) {
    const select = document.getElementById('critical-analysis-select');
    const selectedTech = select ? select.value : '';
    const feedbackEl = document.getElementById(`feedback-${sectionNumber}-${interactionId}`);

    // Get interaction data to validate against
    const interactionDataForCritical = await getInteractionData(sectionNumber, interactionId);
    
    // Validate selectedTech - it might not be present if interactionData.dropdown is empty or not defined
    if (interactionDataForCritical?.dropdown?.length > 0 && !selectedTech) {
        if (feedbackEl) {
            feedbackEl.textContent = 'Selecteer een technologie.';
            feedbackEl.className = 'feedback-message incorrect';
        }
        return;
    }

    // Validate text areas based on interactionData.vragen
    let allQuestionsAnswered = true;
    const data = { technologie: selectedTech };

    if (interactionDataForCritical && interactionDataForCritical.vragen) {
        for (const vraag of interactionDataForCritical.vragen) {
            const inputElement = document.getElementById(`${vraag.id}-input`);
            const answer = inputElement ? inputElement.value.trim() : '';
            console.log(`Checking field ${vraag.id}-input:`, answer); // Debug log
            if (answer.length < 10) { // Assuming minLength 10 for all questions
                allQuestionsAnswered = false;
                console.log(`Field ${vraag.id} too short:`, answer.length); // Debug log
                break;
            }
            data[vraag.id] = answer;
        }
    }

    if (!allQuestionsAnswered) {
        if (feedbackEl) {
            feedbackEl.textContent = 'Beantwoord alle vragen (minimaal 10 tekens per antwoord).';
            feedbackEl.className = 'feedback-message incorrect';
        }
        return;
    }

    // Debug logging
    console.log('Saving critical analysis data:', data);
    console.log('Storage key:', `critical_analysis_${sectionNumber}_${interactionId}_answered`);

    localStorage.setItem(`critical_analysis_${sectionNumber}_${interactionId}_answered`, JSON.stringify(data));
    if (feedbackEl) {
        feedbackEl.textContent = 'Opgeslagen!';
        feedbackEl.className = 'feedback-message correct';
    }

    const container = document.getElementById(`hoofdstuk${sectionNumber}-${interactionId}`);
    if (container && typeof renderInteraction === 'function') {
        setTimeout(async () => {
             // Ensure currentChapterData is available and find the interaction data
            const chapterData = window.currentChapterData || await fetchChapterData(sectionNumber); 
            if (chapterData && chapterData.interacties) {
                const freshInteractionData = chapterData.interacties.find(i => i.id === interactionId);
                if (freshInteractionData) {
                    renderInteraction(freshInteractionData, sectionNumber, container);
                }
            }
        }, 600);
    }
    updateAllChapterProgress();
}

